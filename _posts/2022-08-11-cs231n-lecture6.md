---
layout: post
title: CS231n Lecture6 Review
category: CS231n
tag: CS231n
---

해당 게시물은 [Standford 2017 CS231n](http://cs231n.stanford.edu/2017/syllabus.html) 강의와 2022년 슬라이드를 바탕으로 작성되었습니다.




<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185002080-3fbaafb5-84fd-4ad3-bf4c-f2477aad9542.png">
</p>

<br>





# Training Neural Networks


* 이번 시간에는 nerural network를 학습시키는 방법을 살펴보겠습니다.
    1. One time set up
        * activation functions
        * preprocessing
        * weight initialization
        * regularization
        * gradient checking
    2. Training dynamics
        * babysitting the learning process
        * parameter updates
        * hyperparameter optimization
    3. Evaluation
        * model ensembles
        * test-time augmentation
        * transfer learning
 
<br>
<br>





#  Activation Functions

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185002649-620f3935-02a2-45b8-8fa3-7d153819eb1b.png">
</p>

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185003160-bca92441-cc0b-4ea5-9193-15516de876ae.png">
</p>

* **<span style="color:red">Activation unction(활성화 함수)</span>** 는 **<span style="background-color: #fff5b1">신경망의 출력을 결정하는 식입니다.</span>**
    * 위 그림에서는 하나의 Neuron에서 input $x$ 와 weights $w$ 를 dot product하여 activation function의 input으로 들어가게 되고, non-linear activation function을 거쳐 다음 layer로 출력하게 됩니다.
    * 그림과 같이 신경망에서는 뉴런에 연산 값을 계속 전달해주는 방식으로 가중치를 훈련하고 예측을 진행합니다.
    * 이 때 각각의 활성화 함수는 네트워크의 각 뉴런에 연결되어 있고, 각 뉴런의 입력이 모델의 예측과 관련되어 있는지의 여부에 따라 활성화됩니다. 활성화 함수는 훈련과정이나 역전파 과정에서 계산량이 많으므로 **<span style="background-color: #fff5b1">비선형성 및 효율성이 중요</span>** 합니다.
* Activation function은 크게 3가지로 분류할 수 있습니다.
    1. **<span style="background-color: #fff5b1">Binary Step function</span>**
        * 다중 분류 문제에서 다중 출력을 할 수 없습니다.
    2. **<span style="background-color: #fff5b1">Linear Activation function(선형 활성화 함수)</span>**
        * Step function과 달리 다중 출력이 가능합니다.
        * 하지만 backpropagation 사용이 불가능합니다.(물론 사용 자체는 가능)
            * 역전파는 함수를 미분하여 사용하는 과정인데 선형함수의 미분은 상수이기 때문에 입력값과 무관한 결과가 나오기 때문입니다.
        * 또한 얻을 수 있는 정보가 제한적이어서, hidden layer 사용이 의미가 없어집니다.
            * 활성화 함수를 여러 층에서 쓰면서 필요한 정보를 얻어야 하는데, 선형함수를 여러 번 사용하는 것은 마지막에 선형함수 한 번 사용하는 정도밖에 안됩니다. 따라서 hidden layer를 여러 번 사용하는게 의미가 없게 됩니다.
    3. **<span style="background-color: #fff5b1">Non-linear activation function</span>**
        * 위와 같은 단점들 때문에 보통 비선형 함수를 사용합니다.
        * **<span style="color:red">입출력간의 복잡한 관계를 만들어서 필요한 정보를 얻는 것</span>** 입니다.
        * 이는 Linear activation function과 달리 backpropagation이 가능하고, hidden layer를 통해 더 많은 정보들을 얻는 게 가능해지기 때문에 사용합니다.

결과적으로, 모든 layer(혹은 node)에서 어떠한 activation fcuntion을 갖는데, 이때 activation fcuntion이 없다면 전체 neural network가 단순한 linear model과 다를바 없게 되기에 activation fcuntion의 역할은 상당히 중요합니다. 그러므로 **<span style="background-color: #fff5b1">linear한 모델에 non-linearity(비선형성)를 부여하기 위해</span>** sigmoid 나 ReLU 와 같은 non-linear activation function(비선형 활성화 함수)을 사용했습니다.

<br>
<br>





# Type of activation function

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185005178-92af94ec-e3dd-46fc-bb23-7ef1ab966062.png">
</p>

여러가지의 Activation function 각각이 어떤 특징을 갖고있고, 어떤 장단점이 있는지 살펴보겠습니다. 

<br>
<br>





# Activation Function: Sigmoid

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185005735-74526390-35d1-446e-911a-95954081732a.png">
</p>

* 전통적으로 사용해온 활성함수로서, Sigmoid 함수는 로지스틱 회귀분석으로부터 왔고, 확률적인 해석이 가능합니다. 따라서 확률과 비슷하게 [0, 1] 값을 가집니다.
    * $𝜎(x)\ =\ 0.8$ 이면, 다음 레이어의 특정 노드를 활성화시킬 확률이 0.8이라고 해석할 수 있습니다.
    * 또한 the presence or absence of a boolean variable의 확률로 해석할 수 있습니다.
* 입력의 값이 크면 Sigmoid의 출력은 1에 가까울 것이고, 값이 작으면 0에 가깝습니다.
* 즉, 시그모이드(Sigmoid)는 $x$ 값을 받아서 0 ~ 1 사이의 값으로 뭉갭니다(squash).

하지만 Sigmoid function은 3가지 문제점이 있습니다.
1. **Saturated neurons “kill” the gradients**
2. **Sigmoid outputs are not zero-centered**
3. **exp() is a bit compute expensive**

<br>



## Problem 1. Saturated neurons “kill” the gradients

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185008872-0b663931-1d87-4f48-b3ce-3b1fec7882ad.png">
</p>

* **<span style="background-color: #fff5b1">Sigmoid function의 saturated neuron이 gradient를 죽입니다.</span>**
    * 여기서 말하는 **<span style="color:red">saturated</span>** 의 의미는 input값이 아주 커지거나 작아져서 sigmoid 함수의 0, 1에 가까운 평평한 곳(거의 수평인 부분)에 위치한다는 의미입니다.
    * **<span style="color:red">ssigmoid function은 처음과 끝 부분에 flat한 형태를 갖고있기에 zero-gradient의 saturated regimes(포화 상태)를 가져 이는 사실상 gradient를 죽게하여 network가 robust한 학습을 어렵게 합니다.</span>**
    * 왜냐하면 sigmoid의 경우 양 끝단으로 다가갈수록 gradient는 0에 더 가까워지고, computational graph의 노드에서는 upstream gradient가 0에 근접한 수이면 downstream gradient도 0에 근접하게 되는데, 이 때문에 모델이 'deep' 해질수록 레이어의 gradient가 0이 되어 학습이 진행되지 않는 '죽은' 레이어가 생기게 됩니다.
        * 즉, sigmoid를 사용하면 Sigmoid의 입력이 0 근처의 값이 들어와야만 한다는 강력한 제약조건이 붙습니다.
        * 이러한 saturation을 포함해 $w$ 의 gradient가 0으로 수렴해 update가 중지하는 현상을 **<span style="color:red">gradient vanishing</span>** 이라 합니다.

<br>

Sigmoid의 그래프와 Sigmoid의 미분 그래프 및 수식을 그려보면 다음과 같습니다.

### 그래프
<p align="center">
<img src="https://user-images.githubusercontent.com/77891754/178914026-082d5f1b-83f8-4683-a449-fb7ea6d563d0.png" alt="activation f" style="zoom:30%;"/>
</p>

<br>

$$
\frac{∂\sigma(x)}{∂x} = \sigma(x)(1-\sigma(x))
$$

<br>

### What happens when x = -10?
* $\sigma(x)\ =\ ~0$
* $\frac{∂\sigma(x)}{∂x} = \sigma(x)(1-\sigma(x)) = 0(1 - 0) = 0$
* 즉, $x$ 가 $-$ 로 갈수록 graph에 기울기가 거의 없으므로, gradient가 0이 됩니다.

### What happens when x = 0?
* $\sigma(x)\ =\ ~0.5$
* $\frac{∂\sigma(x)}{∂x} = \sigma(x)(1-\sigma(x)) = 0.5(1 - 0.5) = 0.25$
* 즉, $x = 0$ 근처 일때 graph에 기울기가 있으므로, 적절한 gradient를 얻을 수 있습니다.

### What happens when x = 10?
* $\sigma(x)\ =\ ~1$
* $\frac{∂\sigma(x)}{∂x} = \sigma(x)(1-\sigma(x)) = 1(1 - 1) = 0$
* 즉, $x$ 가 $+$ 로 갈수록 graph에 기울기가 거의 없으므로, gradient가 0이 됩니다.

정리하자면, input $x$ 가 다소 정성적인 표현이지만, 조금만 크거나 작은값이라면 sigmoid function을 사용할 때 backprop과정에서 local gradinet(dL/dw)는 0에 가깝게 수렴하게 되고, 이는 upstream gradient가 어떻든간에 chain rule을 통해 downstream gradient가 0에 가까운 매우 작은값만큼 update됨을 뜻합니다. 이는 이후의 backprop에서도 layer들도 saturation 되어 w가 매우 작은 값으로 update됩니다.

이러한 현상을 **<span style="color:red">gradient가 killed</span>** 되었다라고 표현하며, 더 나아가 Deep neural network에서 saturation을 포함해 계속해서 1보다 작은 값들이 곱해지다 보면 $w$ 의 gradient가 0으로 수렴해 update가 중지하는 현상이 발생하는데, 이를 **<span style="color:red">gradient vanishing</span>**이라 합니다.

<br>

## Problem 2. Sigmoid outputs are not zero-centered

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185017411-5b53a7b8-b15f-4e68-a948-65c729416fa0.png">
</p>

* **<span style="background-color: #fff5b1">Sigmoid function의 output이 zero-centered가 아니라 input이 어떻든지 항상 0~1 사이의 positive값을 출력합니다.</span>**
* 뉴런의 뒤쪽 레이어 뉴런들이 0이 중심이 아닌 데이터를 얻기 때문에 경사하강법의 dynamics에 영향을 미치게 됩니다.
* 이전 layer에서 sigmoid function을 사용했다고 하였을때 input $x^{(l)}$ 는 positive값이 되고 이때 $w^{(l)}$ 의 gradient는 어떻게 되는지 생각보겠습니다.
    * $x^{(l)}$ 이 항상 positive이기 때문에 $w^{(l)}$ 에 대한 local gradient는 항상 positive입니다.
    * $f = \sum w_ix_i + b \\ \frac{∂f}{∂w_i} = x_i = (positive) \\ \frac{∂L}{∂w_i} = \frac{∂L}{∂f}\frac{∂f}{∂w_i} = \frac{∂L}{∂f}x_i$
    * 위 상황에서 sigmoid는 $\frac{∂f}{∂w_i} = x_i$ (local gradient)가 항상 양의 값이기 때문에, $\frac{∂L}{∂w_i}$ 는 $\frac{∂L}{∂f}$ (upstream gradient)와 항상 같은 부호를 갖게 됩니다.
* 정리하자면 sigmoid function의 **<span style="color:red">input에 모두 양수값</span>** 으로 들어가게 된다면, **<span style="background-color: #fff5b1">모든 $W$ 에 대한 gradient는 upstream gradient와 같은 부호 (모두 양수 혹은 모두 음수)를 가지게 됩니다.</span>**
    * 따라서 모든 gradient는 **<span style="color:red">모두 같은 부호</span>** 를 가집니다.
    * 또한 이는 gradient에 의해 $W$ 가 **<span style="color:red">학습되는 방향을 제한</span>** 시키게 됩니다.
    * 즉, 파라미터 업데이트를 할 때 모두 같이 증가하거나, 모두 같이 감소할 수 밖에 없습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185020635-ef7d2c1e-2ecf-40c5-87b1-b1fcb1dc7af9.png">
</p>

* 따라서, Optimal한 solution으로 곧장 나아가지 못하고, 위 슬라이드와 같이 **<span style="color:red">zig zag path</span>** 로 나아가게 됩니다.
    * 위 슬라이드의 그림을 2차원의 $W$ 라고 가정하고, x축이 $w1$, y축이 $w2$ 라고 하면 다음과 같이 4분면 중 두가지 경우(방향)로만 움직이게 됩니다.
        * $w1$, $w2$ 가 모두 $+$ 면 gradient의 update는 오른쪽 위로 진행합니다.
        * $w1$, $w2$ 가 모두 $−$ 면 gradient의 update는 왼쪽 아래로 진행합니다.
* 업데이트가 될 수 있는 방향이 제한됨으로써 제한된 방향으로 여러 번 반복하여 gradient를 update 해야합니다.
    * 즉, 위 슬라이드 그림의 파란색 선이 gradient가 update되어야 하는 방향이라고 할 때, 파란색 선과 같이 곧게 뻗어나가지 못하고 빨간색 선과 같이 지그재그로 나아가게 되므로 여러번 gradient 업데이트를 해주어야 하는데, 이는 상당히 비효율적입니다.
* 위와 같은 이유로 zero-centered를 원합니다.
    * 같은 말로 **<span style="background-color: #fff5b1">zero-centered가 아니기 때문에 gradient 업데이트가 효율적이지 않습니다.</span>**


위 사항들을 정리하면 다음과 같습니다.
* Sigmoid의 출력은 'zero-centered'가 아니고 항상 양수이므로, 이 경우 신경망의 각 레이어의 입력은 양수만 존재한다는 의미이고, 즉 $x^{(l)}$ 이 항상 positive이기 때문에 $w^{(l)}$ 에 대한 local gradient는 항상 positive입니다.
* 하지만 chain rule에 의해 곱해질 upstream gradient는 positive값이 될 수도 negative값이 될 수도 있습니다. 이는 (update되어야할)downstream gradient가 항상 upstream gradient의 부호(positive or negative)와 같아진다는 것이고, 이는 항상 같은 부호를 갖고(+ or -) update가 되어 아래의 그림과 같은 zigzag pattern현상이 발생하여 학습(update)속도가 느려지게 됩니다.
* 또한 이러한 움직임으로 인한 노이즈는 데이터의 차원이 크면 클수록 많아집니다. 특히 step의 크기, learning rate가 크면 이러한 노이즈는 더욱 증가합니다.
    * 하지만 이 문제는 데이터 1개에 대해서 학습을 진행하기보다 mini batch를 사용한다면 어느 정도 방지할 수 있습니다.
    * mini batch를 사용하면 weight의 step은 각 batch의 step의 합으로 이루어져 있기때문에 weight의 모든 원소에 대한 step의 부호가 같은 일(all negative, all positive)은 일어나기 힘들기 때문입니다.

<br>

## Problem 3. exp() is a bit compute expensive

* **<span style="background-color: #fff5b1">또한 Sigmoid의 $exp()$ 는 비싼(cexpensive) 연산을 가지고 있습니다.</span>**
    * 즉, $exp()$ 연산이 다른 기본 연산(+,- 등) 에 비해 복잡하고 시간이 걸립니다.
    * 'ReLU'와 같은 것들에 비하면 매우 값비싼 연산입니다.
    * GPU를 사용할 때는 메인 메모리와 GPU 메모리 간의 데이터 이동이 대부분의 시간을 잡아먹기에 상관이 없지만, 모바일에서 구동할 때나, GPU를 사용할 수 없는 환경에서는 매우 치명적인 문제가 됩니다.
* 하지만, 이 문제는 다른 문제들에 비해 큰 문제까지는 아닙니다.

<br>





# Activation Function: Hyperbolic Tangent(tanh)

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185026453-fc8e90ff-1158-473b-881e-a99ac2fbcc63.png">
</p>

* 다음은 Hyperbolic Tangent(tanh) activation function 으로 squash된 형태입니다.
* tanh는 sigmoid 함수와 유사하지만, 큰 차이점은 tanh는 zero-centered 되었다는 점입니다. tanh 함수는 입력값을 받아 -1 ~ 1 사이의 output 을 출력합니다.
    * zero-centered(0에 중심) 되어있으므로, single element에 대해서 $w$ 의 그래디언트 방향이 다양해질 수 있습니다.
* tanh function은 기본적으로 scaled and shifted version of sigmoid으로 **<span style="color:red">zero-centered 문제는 해결</span>** 하였지만 **<span style="color:red">여전히 x가 크거나 작은 값일때, saturation현상</span>** 을 갖게됩니다.
    * 여전히 saturated 되는 구간에서 gradient가 평평해져 gradient가 0으로 수렴하는 문제(kill gradient)가  있습니다.
    * **<span style="color:red">즉, gradient vanishing 문제가 여전히 존재</span>** 합니다.
* 또한 exp term이 4개라 연산속도가 느립니다.

<br>





# Activation Function: Rectified Linear Unit(ReLU)

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185028699-8c3ca294-ce6d-48ea-91a3-414b061c2223.png">
</p>

* 다음은 ReLU activation function으로, non-linear하면서 가장 심플하여 가장 빠르고, 입력이 음수면 값이 0, 양수면 입력 값 그대로를 출력합니다.
* 장점
    * **<span style="background-color: #fff5b1">+의 구간에서 saturation되지 않습니다.</span>**
        * 즉, input의 절반은 saturation되지 않고 gradient가 살아있습니다.
        * input이 positive값이라면, 아무리 큰 값이어도 kill될 일은 없습니다. 
    * **<span style="background-color: #fff5b1">단순히 max 연산이라서 계산 효율 및 연산 속도가 굉장히 빠릅니다.</span>**
        * 음수 부분을 일부 정보에 대한 무시와 수용이 일어난다고 볼 수 있습니다.
        * AlexNet에서 sigmoid, tanh에 6배가량 빠르게 loss에 수렴합니다.
        * 따라서, sigmoid나 tanh에 비해 더 빨리 수렴하게 됩니다.
    * 실제 생물학적으로도 sigmoid보다 생물학적 뉴런과 더 유사한 출력 형태입니다.
* 단점
    * **<span style="background-color: #fff5b1">sigmoid 처럼 zero-centered가 아닙니다.</span>**
        * output이 positive 또는 0 값만을 갖기에 not zero-centered ouput 문제를 가지므로, 여전히 zig-zag pattern 현상을 겪습니다.
    * **<span style="background-color: #fff5b1">x가 0보다 작은 영역에서 gradient가 죽어버립니다.</span>**
        * input이 양수일때는 saturated 되지않지만 반대로 음수일때는 local gradient가 정확이 0을 갖게되어, 역전파시 downstream gradient은 0이 되고, 이후 계속 0을 전파하여 saturated되는 문제를 가집니다.
            * sigmoid는 0에 수렴한 값을 갖지만(output으로) ReLU는 명백히 zero-gradient를 갖기에 아예 update가 멈추게 됩니다.
        * 즉, ReLU 에서 input이 음수일때는 sigmoid에서 발생하던 문제와 동일하게 saturated되어 전체 gradient의 절반이 죽어버리는(0이 되어버리는) 문제가 발생합니다. -> **<span style="color:red">dead ReLU</span>**
        * 따라서, initialization에서 운이 좋지 않은 몇개의 neuron들은 gradient가 update가 되지 않습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185031372-9da5258d-ed8f-44bd-a926-926df7755170.png">
</p>

* ReLU gate의 local gradient는 0 또는 1입니다.
    1. x = -10
        * local gradient가 0이므로, downstream도 0이 됩니다.
    2. x = 0
        * 부동소수점 연산을 하므로, 고려하지않아도 되는 상황입니다.
    3. x = 10
        * local gradient가 1이므로, upstream값이 그대로 downstream으로 전달됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185031600-a658fd3e-b910-4a3a-9378-d8ce65681522.png">
</p>

* 위 슬라이드와 같이 traing data들이 분포한다고 할때, 데이터들이 분포하는 위치를 data cloud라고 생각하겠습니다.
* ReLU는 가중치 평면(초록 빨강 직선)의 절반(한 쪽 방향)만 activate 한다는 것을 알 수 있습니다.
    * 즉, ReLU를 지나면서 절대 그래디언트가 업데이트되지않는 영역이 생길 수 있습니다.
    * 가중치 평면이 data cloud와 멀리 떨어져 있으면, input data에 대해서 activate 되지 않고 가중치(W)가 업데이트 되지 않아 "dead ReLU" 가 발생할 수 있습니다.
    * 업데이트가 정상적으로 되기 위해서는 위 그림에서 초록색 가중치 평면 처럼 activate되는 data들이 존재하여 gradient가 살아있어야합니다.

몇 가지 이유로 이런 일이 발생할 수 있습니다.
* **<span style="background-color: #fff5b1">첫 번째는 $W$ 초기화를 잘못했을 경우</span>**
    * $W$ 초기화 시 $W$ 평면이 input data cloud와 멀리 떨어진 값으로 초기화 되었을때 dead ReLU 현상이 발생합니다.
* **<span style="background-color: #fff5b1">두 번째는 learning rate가 지나치게 높은 경우</span>**
    * 처음에 적절한 $W$ 평면에서 시작하더라도 학습과정 중에 learning rate가 높아 지나치게 크게 update 해서 $W$ 평면이 data cloud와 멀리까지 가버린다면 **<span style="color:red">dead ReLU</span>** 현상이 발생합니다.
    * 즉, 처음에는 학습이 잘 되다가 갑자기 죽어버리는 경우 입니다.
* 실제로 학습을 다 시켜놓은 네트워크를 살펴보면, 10~20% 가량은 dead ReLU가 되어 있습니다.
    * 하지만 네트워크 학습에 크게 지장이 있지는 않습니다.

실제로 ReLU를 초기화할 때 positive biases(0.01)를 추가해 주기도 합니다. 이는 가중치를 업데이트 할 때 active ReLU가 될 가능성을 높여주기 위함입니다.

참고로 모든 ReLU 계열의 함수들은 0에서 미분이 불가능하여 임의로 0+나 0-에서의 gradient 값으로 선택하는데, 확률적으로 입력이 0으로 주어지는 경우는 매우 드물기에 어떤 것을 선택하던지 상관없습니다.

<br>





# Activation Function: Leaky ReLU & PReLU

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185043040-fc8a8b17-02bd-478e-8743-7b073e12b38c.png">
</p>

* Leaky ReLU
    * ReLU를 변형한 형태입니다.
    * Dead ReLU문제점 해결을 위해, negative값에 대한 그래디언트 값을 0으로 만드는 것 보다 조금이라도 업데이트되는 방안을 고려했습니다.
    * **<span style="background-color: #fff5b1">x가 0보다 작은 영역에서도 작은 기울기를 줌으로써 saturation하지 않습니다.</span>**
    * 여전히 max연산을 사용하므로, sigmoid나 tanh에 비해 ReLU와 동일하게 계산에서 효율적입니다.
    * 결과적으로 saturation되지 않아 ReLU 에서 발생하는, neuron이 죽는 문제(dead ReLU)를 해결</span>** 했습니다.
* Parametric Rectifier(PReLU)
    * Leaky ReLU에서 0.01을 하드코딩한 것과 달리, 이 값을 $α$ 라는 learnable parameter(backprop으로 학습됨)로 조절하는 형태로, backpropagation단게에서 $α$ 에 대한 그래디언트가 계산되어 업데이트가 됩니다.
    * Leaky ReLU에 **<span style="background-color: #fff5b1">더 많은 유연성을 제공</span>** 합니다.

<br>





# Activation Function: ELU

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185044977-a59faada-a193-42fc-86bd-066eea6f57bb.png">
</p>

* ELU(Exponential Linear Units)는 ReLU의 이점들을 모두 가져오며 **<span style="background-color: #fff5b1">더 smooth</span>** 합니다.
* 출력값이 zero-mean와 가까워져 sigmoid와 ReLU에서 발생한 zero-centered가 되지 못해 학습이 비효율적으로 이루어진다는 문제점을 해결했습니다.
* 지수함수를 이용하여 입력이 0이하일때 부드러운 곡선을 갖습니다.
    * ReLU와 Leaky ReLU의 중간 형태
    * **<span style="background-color: #fff5b1">ReLU의 '음수값을 0으로 죽이는 문제'에 대해 leaky relu보다 노이즈에 더 강건하게 대응합니다.</span>**
    * 의도적으로 negative saturation regime을 설계했는데, Negative 영역은 noise일 확률이 높기 때문에 학습을 하면 overfitting 되거나 성능에 악영향을 미칠 수 있으므로, x가 0보다 작은 영역에서 약간의 saturation을 허용하는 것(neuron(gradient)이 죽는 것)이 noise에 조금 더 robust 하다는 주장입니다.
* 연산에 exp()이 포함되어 있습니다.
    * exp 연산의 결과값에 1을 빼주는데, 이는 gradient가 0이 나오는 것을 막기 위해 사용한다고 하며, 거기다 임의의 hyperparameter alpha를 곱해서 스케일 해줍니다.
    * 기존 ReLU의 문제를 해결할 수 있지만 exp 연산의 비용이 ReLU와 비교하면 매우 크다는 한계를 가집니다.

<br>





# Activation Function: SELU

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185268734-f8b26465-2f96-4da4-b4f7-0f46b384e86c.png">
</p>

* SELU(Scaled Exponential Linear Units)는 심층 신경망의 자기 정규화(Self-normalizing)에 더 잘 작동하는 ELU의 확장 버전입니다.
    * 아주 deep한 네트워크를 설정하면, BatchNorm없이도 계속 activate되는 람다, 알파값들이 mean = 0, sd = 1로 normalization된 후, 다음 레이어에 들어갑니다.
    * 즉, 배치 정규화(Batch Normalization)없이 심층 SELU 신경망을 학습할 수 있습니다.

<br>





# Activation Function: Maxout

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185270067-631455c8-ca7b-4ed8-981f-1362050948dd.png" style="zoom:25%;">
</p>

* Maxout Neuron은 ReLU와 Leaky ReLU를 일반화한 형태입니다.
    * 2개의 linear function에서 max연산을 취하기 때문에 일반화라고 표현했습니다.
    * maxout은 두 가지 파라미터들($W$, $b$)을 각각 연산에 더 큰 값을 선택하는 방식으로 진행됩니다.
* 장점으로, Linear이므로, saturate하지 않아서 neuron이 죽는 문제가 없습니다.
* 단점으로, 뉴런당 파라미터의 수가 2배가 됩니다.

<br>





# Activation Function Summary

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185270038-470a1bd9-8f4f-4705-bc57-0158dfae1c5f.png">
</p>

* 유명한 네트워크 아키텍쳐에서는 활성함수의 차이가 크게 나지 않습니다.
* 또한 네트워크 아키텍쳐마다 제일 accuracy가 높은 활성함수가 다른 것으로 보입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185271136-0090c6a5-0c39-4b28-80e7-55a0179f6976.png">
</p>

* Activation Function에 대해서 정리하자면,
    * 특별한 이유 없으면 ReLU를 쓰면 무난하다.
    * 따라서, ReLU를 사용하고, 만약 더 높은 accuracy를 끌어올려야하는 상황이라면, Leaky ReLU, ELU, SELU, GELU를 활용해보면 됩니다.
    * 다만 sigmoid와 tanh의 사용은 피해야 합니다.
* 그리고 지금까지 다룬 Activation Function 모두 단조함수인데, 단조함수가 아니라 Cosine 함수 같은 그래프를 그리는 함수를 사용할 경우, 모델의 학습에 문제가 생기기 쉽습니다.
* 그래도 불가능한 것은 아니라서 드물게 사용되기는 하지만, GELU와 같이 단조함수가 아닌 activation도 있습니다.

<br>
<br>





# Data Preprocessing

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185271906-81db0a25-559c-4a5e-a500-528bd75a1213.png">
</p>

* 일반적인 머신러닝 문제에서 실제 네트워크를 훈련시킬 때는 zero centering 후, standard deviation으로 normalize를 수행합니다.
    * Input이미지가 2차원상의 점 하나에 대응된다고 가정할 때, Original데이터가 타원형으로 펼쳐져 있습니다.
        * 0번째 dimension: 샘플 하나하나 해당
        * 1 ~ 3번째: 컬러채널, 세로, 가로에 해당
    * **<span style="background-color: #fff5b1">Zero-centered data</span>**
        * data 자체를 dim=0에 대해 mean시켜서, $X$ 에 대해서 빼주는 것입니다.
        * 데이터 군집을 모든 차원에 대해 원점으로 이동시킨다는 의미가 있습니다.
        * 즉, 데이터를 중앙으로 모이게 해줍니다.
        * 평균을 0 으로 만들어 zero-centered 한 데이터로 만들어주는 이유는 sigmoid 활성화 함수의 zero-centered가 안되었을때 발생하는 문제점을 생각하면 되는데, data가 모두 양수이거나 모두 음수일 경우, backpropagation 과정에서 gradient가 모두 같은 부호가 되어 학습이 비효율적인 방향으로 일어난다는 문제가 발생했기 때문에, 이러한 방법론을 사용합니다.
    * **<span style="background-color: #fff5b1">Normalized data</span>**
        * 각 variable별로 std를 샘플에 대해서 reduction해서 나누는 것입니다.
        * Normalize를 한 후, 위 아래와 좌우의 변동성이 균등하게 조절됩니다.
        * 즉, 데이터를 특정 범위 안으로 모이게 해줍니다.
        * normalization 을 수행하는 이유는 입**<span style="background-color: #fff5b1">력 데이터의 모든 차원이 동일한 범위 내에 있게 만들어줘서 동등한 기여(contribution)을 하게 함을 위한 것</span>**입니다. 만약 특정 차원의 분포만 엄청 넓게 있다보면 해당 차원의 데이터만을 중요하게 학습하게 될 것이기에, 모든 차원의 데이터를 같은 분포로 전처리 해줍니다.
* 즉, 모델을 학습시키기 전에 데이터를 전처리를 함으로써 데이터의 분포를 개선시키는데, 각 데이터에 평균을 빼서 데이터가 zero-centered 하게 만들고, 표준편차로 나눔으로써 각 feature들의 분산을 동일하게 해줍니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185274526-b783a338-49e7-4b80-a15f-3dcdb840ce72.png">
</p>

그렇다면 궁극적으로 왜 preprocessing이 필요할까?
* non zero-centered를 생각해보면, 만약 모든 데이터가 양수 혹은 음수를 가지는 경우 gradient도 한쪽으로 편향되어 update되는데 데이터의 평균을 0으로 만들어 주면 이를 방지할 수 있습니다.
* **<span style="color:red">즉 Loss가 최소인 지점은 변하지 않지만, preprocessing을 하면 gradient계산에 조금 유리해집니다.</span>**
    * Before normalization
        * 분류 손실(classification loss)은 가중치 행렬의 변화에 매우 민감하며, 최적화하기 어렵습니다.
        * Center가 0이 아니게 데이터들이 분포해있습니다. 이런 경우에서 만약 decision boundary의 slope가 조금 바뀐다면, slope의 미미한 변화에도 데이터의 분류 상황이 많이 바뀌며, classification loss가 많이 바뀝니다. 결론적으로 **<span style="background-color: #fff5b1">optimization process를 어렵게 만듭니다.</span>**
    * After normalization
        * 가중치의 작은 변화에 덜 민감하고, 최적화하기 쉽습니다.
        * 원점에 데이터들이 분포해있습니다. 이런 상황에서는 작은 변화에 덜 민감합니다. 따라서 **<span style="background-color: #fff5b1">optimization process가 비교적 쉬워집니다.</span>**

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185275670-f08c961d-4b9f-4ffc-a67d-b0c976fd1011.png">
</p>

* Machine learning에서 정형데이터의 경우, PCA나 whitening 같이 더 복잡한 전처리 과정도 있습니다.
    * 이는 각각 decorrelated data, whitened data를 뜻합니다.
    * image 데이터를 다룰 때에 굳이 쓰지않음
* 실제로, **<span style="background-color: #fff5b1">image 데이터의 경우는 데이터 전처리 과정으로 zero-mean만 수행하고, 다른기법은 잘 사용하지 않습니다.</span>**
    * 보통 이미지는 각 차원의 분포가 또는 각 차원 간의 크기(scale)가 이미 어느 정도 동일하게 만들어졌기 때문입니다.
        * ex. RGB 값은 각 차원 모두 0~255 사이의 값을 가짐
    * 일반적으로 이미지를 다룰 때는 PCA같이 더 낮은 차원으로 정사영(projection)시키지 않습니다.
    * CNN에서는 원본 이미지(original data) 자체의 공간 정보를 활용해서 이미지의 공간 구조를 확보할 수 있습니다.
    * 엄밀하게 따지자면, 첫번째 layer의 input에서만 zero mean이 되고, 네트워크가 깊어지면서 데이터는 zero mean이 되지 않음

<br>

# Data Preprocessing Summary

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185276382-8ce25a97-dbc6-44d0-9579-ce4fb186bda0.png" style="zoom:25%;">
</p>

* 정리하자면 다음과 같습니다.
    * image data를 다룰때는 기본적으로 zero-mean 으로 전처리를 해줍니다.
    * 하지만 일관적이지 않으며, 각 모델 또는 데이터에 맞게 진행해 주면 됩니다.
    * 다음은 zero-mean을 하는 대표적인 process 입니다.
        1. 전체 데이터의 평균을 구해서 각 데이터마다 그 평균 값을 빼주는 방법
        2. 전체 데이터의 각 채널 마다 평균을 구해 각 데이터의 채널마다 해당 채널의 평균을 빼주는 방법

<br>
<br>





# Weight Initialization

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185277999-395982c0-dcbb-48a7-8074-1760792155e9.png">
</p>

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185278700-7283db56-89d4-46a7-bb0d-6922161a8985.png">
</p>

* **<span style="color:red">Weight Initialization</span>** 은 **<span style="background-color: #fff5b1">처음에 weight가 어떤 값으로 초기화되느냐에 따라서 모델 학습이 잘 되는지 안되는지를 결정하기 때문에, 이 부분은 굉장히 중요한 부분입니다.</span>**
* 만약 fully-connected network에서 모든 Weight를 0으로 초기화(또는 모두 같은 값으로 초기화)한다면 어떻게 될까?
    * **<span style="color:red">0으로 모두 초기화</span>** 를 하면, 해당 layer의 output이 input에 상관 없이 모두 zero가 될 것이이며 (activation funcion이 ReLU일 경우) gradient도 zero가 될 것입니다(마지막 bias 제외). **<span style="background-color: #fff5b1">이는 weights update가 되지 않는다는 뜻이고 학습이 되지 않습니다.</span>**
    * **<span style="color:red">Constant로 초기화</span>** 해도 모든 neuron의 gradient가 같아질 것이기 때문에 "not having symmetry breaking" 라고 표현하며, 이는 어느 neuron(one hidden unit)이던 forward pass에선 모든 input feature에 대해 같은 weights로 반응하며, backprop 에선 **<span style="background-color: #fff5b1">모든 feature에 대응하는 weights들이 same gradient가 적용되어 같은 크기로 update된다는 것을 의미합니다.</span>**
    * 이 때문에 모두 같은 방식으로 update가 되며, 모든 neuron이 같아지게 되는 문제가 있습니다.
        * 모델이 이런 상황에 처하게 되는 것을 **<span style="color:red">'symmetry braeaking'</span>** 에 실패했다고 하며, 그렇기에 weight을 0 또는 Constant로 초기화해서는 안됩니다.
        * $W$ 의 변화가 없는 것을 딥러닝에서 symmetry라고 표현합니다.
* 그러므로 가중치 초기화시 W와 b가 모두 조금씩 달라서, layer의 모든 노드들이 다른 역할을 하도록 만들어주어야 다음 process에서 각자의 역할을 찾아갑니다.

<br>





# Test1: Initialize with small random values

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185286994-6f2daa44-8ab4-4908-99cc-e157a60e46bf.png" style="zoom:25%;">
</p>

* 이전 zero initialization의 문제점을 보완하고자 **<span style="color:red">small random values</span>** 로 초기화하려 합니다.
* $W$ 를 작은 난수값으로 초기화(Gaussian distribution, standard deviation = 0.01)하면 어떻게 될까?
    * zero-mean, unit-std를 갖는 가우시안 분포를 따르는 값들을 0.01 scaling 시켜주어 (std=0.01 로 만듦) 초기화시켜준 것입니다.
    * **<span style="background-color: #fff5b1">작은 네트워크에서는 symmetry breaking 할 수 있어서 괜찮지만, 깊은 neural networks에서는 문제가 됩니다.</span>**

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185310650-f073448d-a5c7-4785-b987-d74eb9ee2e05.png">
</p>

* 깊은 네트워크에서의 문제를 위 슬라이드를 통해 더 자세히 살펴보겠습니다.
    * Forward pass에서의 문제
        * 서로 작은 $W$ 값들을 계속해서 곱하면서 이 값들이 매우 빠르게 작아지기 때문에 Activaiton이 0이 됩니다.
        * 처음에는 mean = 0에 적당한 std로 분포되어 있지만, layer가 쌓이면서 점점 0쪽으로 sqeeuze된다. 즉, activated값이 균질하지 않아집니다.
        * 이러한 문제가 발생하는 이유는 $W$ 가 너무 작은 값이다보니 $Wx$ 연산 과정을 하고 tanh을 거친 출력값들 또한 엄청 작은 값이 나오게 될 것이고, 이 과정이 반복되어 깊은 레이어에서는 거의 0에 수렴하는 출력값이 나오게 될 것입니다.
    * Backward gradient update에서의 문제
        * 작은 $W$ 값으로 인해 input $x$가 매우 작습니다. 즉 점점 0에 수렴합니다.
        * 따라서, local gradient $dW/df = x$ 도 작아지고, 결국 가중치는 아주 작은 gradient를 얻게 되어 update가 일어나지 않게 됩니다.

<br>





# Test2: Initialize with big random values

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185310681-088f8fb8-3b9f-43c8-aa89-9e912737cdd4.png">
</p>

* **<span style="color:red">큰 난수값</span>** 으로 초기화(Gaussian distribution, standard deviation = 0.05)하면 어떻게 될까?
    * $W$ 가 1또는 -1에 수렴하게 됩니다.
    * 이때, local gradient 계산시, tanh함수는 -1, 1값에 대해 gradient를 0근처로 반환한다. 따라서 또 다시 학습이 거의 되지않습니다.
    * 따라서, 값들이 saturation 되어 gradient가 0이되고, update가 일어나지 않습니다.

<br>





# Xavier Initialization

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185311061-e479343f-1399-4034-9453-d79b2638aee7.png">
</p>

* 큰 난수값과 작은 난수값 모두 문제가 있습니다. 따라서, 적절한 값으로 초기화 하는 방법이 필요합니다.
    * 보통 랜덤하게 초기화된 뉴런의 출력값은 input 개수가 많아질수록 큰 분산을 갖는다고 합니다.
* **<span style="color:red">Xavier Initialization</span>** 은 **<span style="background-color: #fff5b1">입력과 출력의 분산이 동일하도록 하는 초기화 방법</span>** 입니다.
    * 입력의 분산이 출력의 분산과 동일하도록 weight가 어떻게 되어야 할지를 유도하면, Xavier Initialization의 공식을 얻을 수 있습니다.
    * 가우시안 분포에서 뽑은 값을 input 수의 제곱근으로 나누어 스케일링함으로써 $W$ 값을 정합니다.
    * 각 레이어의 출력값들이 비슷한 분포(가우시안 분포)를 가지는 것을 시각적으로 확인할 수 있습니다.
    * 또한 이러한 분포를 가지는 출력값들이 active region에 있다는 가정이 있어야 학습이 잘 이루어질 수 있습니다.
* Xavier Initialization의 동작 예
    * 입력이 작다면 더 작은 수로 나누게 되고, 더 큰 weight를 얻게 됨
        * 작은 입력과 큰 weight를 곱하므로, 적절한 값이 나오게 됩니다.
    * 입력이 크다면 더 큰 수로 나누게 되고, 더 작은 weight를 얻게 됨
        * 큰 입력과 작은 weight를 곱하므로, 적절한 값이 나오게 됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185318959-40e7222f-ab75-4f49-91b0-3a31fcc2bb0b.png">
</p>

* **<span style="background-color: #fff5b1">결국 Xavier Initialization의 목표는 output노드들의 activation variance와 input노드들의 activation variance가 같도록하는 것</span>** 입니다.
    * Let: $y\ =\ x_1w_1\ +\ x_2w_2\ +\ ...\ +\ x_{Din}w_{Din}$
    * Assume: $Var(x_1)\ =\ Var(x_2)\ =\ ...\ =\ Var(x_{Din})$
    * $Var(y) \\ =\ Var(x_1w_1\ +\ x_2w_2\ +\ ...\ +\ x_{Din}w_{Din}) \\ =\ Din\ *\ Var(x_iw_i)$
    * X와 W가 독립적이라는 가정하에, $Var(x_iw_i)\ =\ (E[x^2_i]E[w^2_i]\ −\ E[x_i]^2E[w_i]^2)$
    * X와 W가 평균이 0라고 가정하면, $(E[x^2_i]E[w^2_i]\ −\ E[x_i]^2E[w_i]^2)\ =\ E[x^2_i]E[w^2_i]\ =\ Var(x_i)Var(w_i)$
    * 이때, $Var(w_i)\ =\ \frac{1}{Din}$ 으로 설정하면, 결과적으로 $Var(x_i)\ =\ Var(y_i)$ 가 됩니다.
 
 <br>





# He Initialization

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185311220-e8aa0d68-b337-4ae8-87b1-6e7f69992285.png">
</p>

* ReLU는 절반의 unit을 죽이기 때문에 Xavier를 사용해서 얻은 분산의 절반이 없어지게 됩니다.
    * 즉 출력의 분산을 반토막 내버려, 출력의 분포가 점점 줄어들게 되므로 ReLU에서는 Xavier initialization이 적절하지 않습니다.
    * 레이어를 거칠때마다 출력의 분산을 반으로 줄이게 되며, 점점 더 많은 값들이 0이 되고, 결국 비활성(deactivated) 됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185311438-30c8b42a-45b1-4ea1-9c78-688d568b5219.png">
</p>

* **<span style="color:red">He Initialization</span>** 은 **<span style="background-color: #fff5b1">Xavier에서 입력을 2로 나눈 초기화 방법</span>** 입니다.
    * 즉, $W$ 를 초기화 할때 가우시안분포를 따라 샘플링한 값을 input의 개수를 절반으로 나눈 값에 제곱근을 나누어 스케일링하는 방법을 사용합니다.
    * Xavier를 사용하면 얻은 분산의 절반이 없어지므로, Xavier의 식에서 입력을 2로 나누게 되면 위와 같이 출력의 분포가 줄어들지 않게 됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185330849-433d5314-e166-4ad0-99eb-110cce3ded68.png">
</p>

Weight initialization은 다양한 방법으로 연구되고 있으며, 우선은 Xavier initialization을 추천합니다.

<br>
<br>





# Batch Normalization

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185332921-01ad5343-a3ba-4a9c-a120-26ed97bb5a61.png">
</p>

<br>

* **<span style="color:red">Batch Normalization</span>** 은 **<span style="color:red">모델의 internal covariate shift를 줄임</span>** 으로써 **<span style="background-color: #fff5b1">learning process를 더 가속화시키는 역할을 함으로써 더 높은 learning rate와 더 빠른 convergence을 허용하고, 모델 weight initialization의 영향을 줄이며, regularize 역할을 합니다.</span>**
* 지금부터 Batch Normalization로 가기위한 Motivation 부터 시작하겠습니다.

<br>

## Motivation: Gradient Vanishing & Exploding Problem

Neural Network에서의 학습시 Global optimization를 하기위해 stochastic gradient descent등의 알고리즘을 통해 parameter(weight and bias)와 Loss간의 관계를 Gradient 기반으로 학습시켜 parameter들을 update 합니다. 이때 parameter의 값들이 Vanishing 또는 Exploding 된다면 학습이 불안정하게 수행되어 Error rate 가 낮아지지 않고 수렴해버리는 문제가 발생하게 됩니다. 결과적으로 Neural Network을 효과적으로 학습시키지 못합니다.

<br>

## Motivation: How to speed up training?

* Gradient vanishing
    * backpropagation algorithm에서 아래 layer로 내려갈수록, 현재 parameter의 gradient를 계산했을 때 앞에서 받은 미분 값들이 곱해지면서 그 값이 거의 없어지는 (vanish하는) 현상을 의미합니다.
* Gradient exploding
    * learning rate가 너무 높아 diverge하는 현상을 말합니다.

deep neural network의 train 속도를 높이는 것은 일반적으로 전체적인 성능 향상에 도움이 됩니다. train의 속도, 즉 gradient method의 converge 속도를 빠르게 하기 위해서는 learning rate를 높게 설정합니다.

하지만 Learning rate의 값이 크면 이 두 가지 현상이 발생할 확률이 높기 때문에 우리는 보통 작은 learning rate를 고르게 됩니다. 그러나 일반적으로 learning rate의 값이 diverge하지 않을 정도로 크면 gradient method의 converge 속도가 향상됩니다.

따라서 **<span style="color:red">본 논문이 던지는 질문</span>** 은 다음과 같습니다.
* **<span style="background-color: #fff5b1">Gradient vanishing/exploding problem이 발생하지 않도록 하면서, input이 zreo-centerd하게 하면서, learning rate 값을 크게 설정할 수 있는 neural network model을 어떻게 design할 수 있는가?</span>**

<br>

## Internal Covariate Shift

Gradient vanishing problem이 발생하는 이유에 대해서는 여러가지 설명이 가능하지만 이 논문에서는 internal covariate shift라는 개념을 제안합니다.

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185341417-0fa2be87-73b7-42ff-96c8-c203059ab875.png">
</p>

* Covariate(공변량) : 종속변수에 대하여 독립변수와 기타 잡음인자들이 공유하는 변량
    * 다른말로 실험 설계에 독립변수로 설정되어 있지 않았지만, 종속변수에 영향을 미칠 수 있기 때문에 통제되어야 할 변수를 말합니다.
    * 즉, 독립변수와 종속변수의 관계를 명확하게 밝히려 할 때 방해가 될 수 있는 요인입니다.
* **<span style="color:red">Covariate shift</span>** : **<span style="background-color: #fff5b1">machine learning problem에서 train data와 test data의 data distribution이 다른 현상을 의미</span>** 합니다.
    * DNN에서 training data를 잘 학습시켜 test data를 잘 분류해야 하기 때문에, DNN 모델이 가지는 가중치는 같은 분포를 띄어야 합니다.
    * 또한 DNN train은 이전 계층에 비선형성을 적용한 후 다음 계층에 대한 입력으로 출력한다는 사실 때문에 복잡합니다. 훈련하는 동안 이전 계층의 매개변수가 변경되기 때문에 입력 분포가 변경됩니다.
    * 서로 다른 분포를 가지는 현상을 covariate shift라 합니다.
* **<span style="color:red">Internal Covariate shift</span>** : **<span style="background-color: #fff5b1">레이어를 통과할 때 마다 Covariate Shift 가 일어나면서 입력의 분포가 변하는 현상</span>** 을 의미합니다.
    * 논문에서는 **<span style="background-color: #fff5b1">단순히 train/test input data의 distribution이 변하는 것 뿐 아니라, 각각의 layer들의 input distribution이 training 과정에서 일정하지 않기 때문에 문제가 발생한다고 주장</span>** 하며, 이렇게 각각의 layer들의 input distribution이 consistent하지 않은 현상을 internal convariate shift라고 정의합니다.

논문에서 이것이 문제가 된다고 주장하는 이유는, 각각의 layer parameter들은 현재 layer에 들어오는 input data 뿐만 아니라 다른 model parameter들에도 영향을 받기 때문이라고 합니다.

기존에는 이런 현상을 방지하기 위하여, activation function를 변경하거나, Careful initialization를 하거나, leanring rate를 작게 취하는 등의 전략을 사용했지만, 그런 방법이 아닌 다른 방법을 통해 internal covariate shift 문제가 해결이 된다면 학습하는 과정 자체가 전체적으로 안정화되는 동시에 더 높은 learning rate를 선택하여 learning 속도를 빠르게하는 것이 가능할 것입니다.

따라서 **<span style="color:red">본 논문의 목표는 internal covariate shift를 줄이는 것</span>** 입니다.

<br>

## bad approach: Whitening

* Whitening
    * 각 layer의 input distribution을 zero mean, unit variance를 가지는 normal distribution으로 normalize
    * 주어진 column data $X∈R^{d×n}$ 에 대해 whitening transform은 다음과 같습니다.

$$
X̂ = Cov(X)^{−1/2}X, Cov(X)=E[(X−E[X])(X−E[X])^⊤]
$$

* 그러나 이런 approach에서는 문제점들이 발생하게 됩니다.
    * multi variate normal distribution으로 normalize를 하려면 inverse의 square root를 계산해야 하기 때문에 필요한 계산량이 많다.
    * 전체 데이터를 기준으로 mean/variance를 training마다 계산하면 계산량이 많이 필요하다.
    * 또한 일부 parameter(bias)들의 영향이 무시됩니다.

따라서 이 논문에서는 이런 문제점들을 해결할 수 있으면서, 동시에 everywhere differentiable하여 backpropagation algorithm을 적용하는 데에 큰 문제가 없는 간단한 simplification을 제안합니다.

<br>

## nice approach: Batch Normalization Transform

* 앞서 제시된 문제점들을 해결하기 위하여 본 논문에서는 **<span style="color:red">두 가지 approach</span>** 를 제안합니다.
    1. 각 차원들이 서로 independent하다고 가정하고 각 차원 별로 따로 estimate를 하고 그 대신 표현형을 더 풍성하게 해 줄 linear transform도 함께 learning 합니다.
    2. 전체 데이터에 대해 mean/variance를 계산하는 대신 지금 계산하고 있는 batch에 대해서만 mean/variance를 구한 다음 inference를 할 때에만 real mean/variance를 계산합니다.

먼저 Whitening approach에서 covariance matrix의 inverse square root를 계산해야했던 이유는 모든 feature들이 서로 correlated되었다고 가정했기 때문이지만, 각각이 independent하다고 가정함으로써, 단순 scalar 계산만으로 normalization이 가능해집니다. 그럼 다시 슬라이드로 돌아가겠습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185516924-cc417c31-fd7b-46d8-8163-b9e51bfb76f8.png">
</p>

* **<span style="color:red">Batch Normalization</span>** 은 **<span style="background-color: #fff5b1">입력의 mini-batch별로 평균과 분산을 계산해서 normalize하는 방법</span>** 입니다.
    * 즉, layer를 통과한 후에도 **<span style="color:red">분포가 Unit gaussian</span>** 이 되도록 하는 방법입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185517202-8a9c9aad-6f73-4e03-9000-43f82438714b.png">
</p>

* 배치당 NxD shape의 x가 있습니다.
    * N: batch size
    * D: Variable수(이전 hidden 노드의 수)
* 각 차원별로 평균(mean)을 각각 계산합니다.
* 하나의 배치 내에서 전부 계산하여 정규화 합니다.
    * 여기서 $ϵ$ 은 계산할 때 0으로 나눠지는 문제가 발생하는 것을 막기 위한 수치적 안정성을 보장하기 위한 아주 작은 숫자입니다.
* **<span style="background-color: #fff5b1">즉, 각 차원에 대한 경험적 평균과 분산을 독립적으로 계산</span>** 합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185517228-9a4d19f7-d844-4db3-b04c-acaeea1cba3c.png">
</p>

* 그러나 이렇게 correlation을 무시하고 learning하는 경우 각각의 관계가 중요한 경우 제대로 되지 못한 training을 하게 될 수도 있으므로 이를 방지하기 위한 linear transform을 각각의 dimension D마다 learning해줍니다.
    * 이 transform은 **<span style="color:red">scaling</span>** 과 **<span style="color:red">shifting</span>** 을 포함합니다.
    * parameter $γ$, $β$ 는 neural network를 train하면서 마치 weight를 update하듯 같이 update하는 model parameter입니다.
* 또 다르게 해석을 하면 Batch Normalization을 진행함으로써 입력을 linear한 부분으로만 제한함으로써 non-linear한 activation function의 영향력이 감소하게 됩니다.
    * 즉 모델의 비선형성을 잃게 되는것입니다.
    * 이를 해결하기 위해 우리는 input의 값을 무조건적으로 linear한 부분에만 제한하는게 아니라 유연하게 조절할 필요가 생깁니다.
    * 또한 실제로는 일부 출력값은 saturation 되어야 노이즈에 좀 더 robust한 경우도 있습니다.
    * 따라서 saturation이 무조건적으로 전혀 일어나지 않는 것보다 얼마나 saturation이 일어날지를 설정할 수 있게 하기위해 scaling과 shifting을 포함합니다.

<br>

## Batch Normalization: Test-Time

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185518114-446500b7-080c-4675-81b6-33025487e3cd.png">
</p>

* Training단계에서는 N개씩의 미니 배치 샘플이 적용되지만, Val/test 단계에서는 계산이 이상해집니다.
    * 배치를 뭘로 볼 것인지가 문제가 됩니다.
* 따라서 유의할 것으로, **<span style="color:red">training과 test코드가 다르게 구현되어야 합니다.</span>**

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185518134-63cd2293-1f66-4aa2-a98b-69c2f92f69d0.png">
</p>

* Test에서는 mean과 std를 계산하지 않고, Training 단계마다 기록되는 mean, variance term을 저장했다가 사용합니다.
    * 예를 들어, training에서의 moving average를 사용해서 값을 구하는 방법 등
* 그리고 test에서 추가적 계산 없이 평균이라는 상수를 사용하기 때문에 Batch Normalization은 Linear operator로 볼 수 있게 되고, 그래서 Fully-Connected Layer나 Convolution Layer와 합쳐질 수 있다고 합니다.

<br>

## Batch Normalization for ConvNets

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185519015-321b6feb-398c-4c54-ba00-f080eaaf0c3d.png">
</p>

* Batch Normalization은 Fully-connected network와 Convolutional network에서 모두 사용 가능합니다.
    * Spatial structure가 포함되는 Conv Net 특성상, Batch norm도 spatial dimension을 고려합니다.
* 즉, fully-connected networks에선 N x D의 input x 를 batch N에 대해 averaging(scale and shift) 시켜 D-dim vector에 normalize 시킵니다.
* Conv net에선 batch dimension N에대해 averaging 시킬뿐 만아니라 모든 spatial dimension인 H,W에 대해서도 averaging 하여 C-dim vector 에 normalize 시킵니다.

<br>

## usually insert

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185520446-c6672eb9-8ac6-4ab8-9672-8cf74d9656ac.png">
</p>

* **<span style="background-color: #fff5b1">주로 Fully connected layer나 Conv layer를 통과한 후에 데이터의 분포가 바뀌기 때문에, 이들을 통과한 후에 batch normalization을 수행하는 것이 일반적</span>** 입니다.
    * 엄밀히 따지자면, Fully connected layer와 달리 Conv layer에서는 출력 Activation Map마다 평균과 분산을 가지고 정규화하게 됩니다.

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185520388-f1694fce-5665-4c8d-bdd1-676b17bafdf0.png">
</p>

* 장점
    * BN을 씌우니까 더 적은 iteration으로 더 높은 accuracy를 달성합니다.
    * deep network에도 학습이 잘 됩니다.
    * 트레이닝 단계에서 regularizaion의 효과가 있습니다.
    * Test단계에서 추가적인 계산이 필요없습니다.
* 단점
    * 하지만 이론적으로 완벽히 증명된 것이 아닙니다.
    * 트레이닝, 테스트시 다르게 작동하므로 버그가 자주 발생합니다.
* 저자가 주장하는 장점
    * 더 큰 learning rate를 쓸 수 있습니다. internal covariate shift를 감소시키고, parameter scaling에도 영향을 받지 않고, 더 큰 weight가 더 작은 gradient를 유도하기 때문에 parameter growth가 안정화되는 효과가 있다.
    * Training 과정에서 mini-batch를 어떻게 설정하느냐에 따라 같은 sample에 대해 다른 결과가 나옵니다. 따라서 더 general한 model을 learning하는 효과가 있고, drop out, l2 regularization 등에 대한 의존도가 떨어집니다.


# Batch Normalization Summary

* Batch Normalization을 요약하면 다음과 같습니다.
    * 입력이 주어지면 미니배치의 평균과 분산을 구하고 normalize합니다.
        * 이때, scaling factor $γ$ 와 shifting factor $β$ 로 normalization의 정도를 조절합니다.
    * Batch Normalization은 gradient flow를 향상시키고, 네트워크를 더 robust하게 해줍니다.
        * 더 많은 learning rate와 다양한 initialization에서 동작하기 때문에 훈련하기 더 쉬워집니다.
    * Batch Normalization은 Regularization의 역할도 수행합니다.
        * 각 layer의 입력(mini batch)은 표본이라고 볼 수 있으므로, 이들의 출력이 normalize되는 것은 각각 표본평균과 표본분산을 통해 normalize되는 것이라고 볼 수 있습니다. 이는 각 layer의 출력은 더이상 해당 mini batch에만 deterministic한 것이 아니라, 전체 데이터들에 영향을 받게 되는 것이라고 해석할 수 있습니다.
        * 즉, X의 representation이 약간씩 jitter되면서 일종의 regularization 효과를 얻게 되는 것입니다.

<br>
<br>





# Babysitting the Learning process

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185523020-ffa8f805-f506-4ae1-b9d3-f63b0e2ce2ca.png">
</p>

* 이제 **<span style="background-color: #fff5b1">학습 과정을 어떻게 모니터링하고 좋은 성능을 내는 하이퍼 파라미터를 어떻게 설정할 것인가</span>** 에 대해 살펴보겠습니다.
* 모델 학습의 전반적인 과정에 대해 단계별로 살펴보겠습니다.

<br>

## Preprocess the data

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185523613-c893e40b-fd2c-4c52-a6b6-a32612710398.png">
</p>

* 우리가 가장 먼저 해야할 일은 데이터 전처리 입니다.
    * zero-mean을 사용합니다.

<br>

## Choose the architecture

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185523633-6e42bd08-8797-499f-9682-ee38ef70d740.png">
</p>

* 그 다음으로는 어떤 아키텍쳐를 사용할지 선택해야합니다.
    * 하나의 hidden layer 와 50개의 뉴런을 가진 모델을 사용해봅니다.

<br>

## Double check that the loss is reasonable

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185524182-60e6d0b6-8e11-41b1-a034-6d6ee08e8e5d.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185524208-ec7ef545-3a49-46c1-a922-d57dc1d5d5ad.png">
</p>

* Loss function도 잘 동작하는지 검사합니다.(sanity check)
    1. Loss가 잘 계산되는지 검사합니다.
        * softmax를 사용하여 -log(1/class수)가 되어야 하기 때문에 -log(1/10) ~ 2.3이 나오는지 검사합니다.
    2. 약간의 Regularization을 주었을 때, Loss가 증가하는지 검사합니다.

<br>

## train

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185524373-a146ee19-4024-473d-861d-2a34e0caf21a.png">
</p>

* 모델학습을 시작합니다.
    * 처음에는 작은 양의 일부 데이터만을 이용해서 Loss가 잘 줄어드나를 확인해야합니다.
    * 이 과정에서 데이터가 적음으로 인해 overfit이 생겨야합니다.
        * 즉, loss가 엄청 작은 값까지 내려가고 accuracy가 엄청 높아야합니다.
    * 이때는 regularization를 사용하지 않습니다.
* 실험을 살펴보면 다음과 같습니다.
    * Loss가 내려감과 동시에 Train Accuracy는 점점 증가합니다.
    * 데이터가 작은 경우라면 모델이 완벽하게 데이터를 overfit할 수 있어야 합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185524420-e1af36de-11bf-4014-9427-49e021882385.png">
</p>

* 모든 sanity check 가 완료됐다면,다음으로 전체 데이터를 이용해 실제학습을 합니다.
* 약간의 regularization을 준 상태에서 최적의 learning rate을 찾습니다.
    * 이때, loss가 크게 변하지 않는다면, learning rate가 작은 경우입니다.
    * Learning rate는 가장 중요한 하이퍼파라미터 중 하나로, 가장 먼저 정해야만 하는 하이퍼파라미터 입니다.
* 위 슬라이드에서와 같이 learning rate를 1e-6으로 설정 후 훈련시, loss는 큰 변화가 없지만 accuracy만 증가하게 되는 경우도 있습니다.(loss는 큰 변화 없지만, accuray는 20%까지 증가)
    * 전체 확률은 널리 퍼져있고, softmax의 loss도 이와 매우 유사하다.
    * 학습이 진행되면서 올바른 방향으로 전체 확률을 약간 이동시킨다면, loss는 여전히 분산되어 있지만 accuracy는 최대로 맞힌 횟수를 헤아리기 때문에 accuracy만 갑자기 증가할 수 있습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185524790-6fe37d62-a671-4edc-a3c5-a90b406e7ae8.png">
</p>

* learning rate를 크게하면(앞에서는 1-e6인데 여기서는 1e6), loss가 exploding하게 됩니다.
    * 결과를 보면 cost가 NaNs, 즉 cost가 발산(exploded)했습니다.
    * 주된 이유는 learning rate가 지나치게 높기 때문입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185524816-49bf2228-62c7-4117-ad5a-c2e8e5895054.png">
</p>

* 이러한 경우에는 다시 값을 줄여서 시도해보고, 그래도 크다면 조금 더 줄이고, 너무 작다면 다시 키우면서 최적의 learning rate를 찾아가면 됩니다.
    * 이 경우 learning rate를 낮춰야하기 때문에, 3e-3으로 했는데, 여전히 발산합니다.
* 보통 learning rate는 1e-3 에서 1e-5사이의 값을 사용합니다.(해당 데이터 한정)
* 이 범위 사이의 값을 이용해서 cross-validation 을 수행해 줍니다.
    * 사이의 값들을 이용해서 learning rate가 지나치게 작은지 아니면 큰지를 결정할 수 있습니다.

<br>
<br>





# Hyperparameter Optimization

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185525950-e48b5e72-38c8-42c5-ad64-392ecd631a38.png">
</p>

하이퍼 파라미터를 어떻게 최적화시키고 그중 가장 좋은 것을 선택하려면 어떻게 해야 하는지 살펴보겠습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185526892-12371ae0-8a3d-4ac9-aac3-460f44dd58d3.png">
</p>

<br>





# Cross-validation strategy

* 하이퍼파라미터 최적화는 다음의 단계로 수행합니다.
    * **<span style="background-color: #fff5b1">First stage</span>**
        * 하이퍼파라미터 값을 넓은 범위에서 설정해보면서(coarse search), 잘 학습되는 적절한 하이퍼파라미터 범위를 찾는다.
        * 몇번의 epoch동안만 돌려봐도 잘 동작하는지 알 수 있므로, 잘 동작하지 않는 경우 바로 학습을 중단하고 다시 잘 동작하는 범위를 찾는 과정을 반복한다.
            * Ex) 학습을 시작한 후, loss가 처음의 값보다 3배 이상으로 커진다면 아주 빠르게 증가한다는 의미이므로, 바로 중단하고 다른 값을 시도
    * **<span style="background-color: #fff5b1">Second stage</span>**
        * 앞의 과정에서 찾은 적절한 범위에서 더 미세하게 찾는다.(fine search)

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185526933-e4dd5e0a-f77b-4f55-8e1f-9de863b95a4c.png">
</p>

* 첫번째 단계인 넓은 범위에서 적절한 값의 범위를 찾는 과정입니다.(coarse search)
    * 여기에서 확인 해야 할 것은 validation accuracy 입니다.
    * 빨간색 박스로 표시된 부분이 fine-stage를 시작할 만한 적절한 값의 범위입니다.
    * 하이퍼 파라미터 최적화 시에는 Log scale로 값을 주는 것이 좋습니다.
        * 즉, 파라미터 값을 샘플링할때 10^-3 ~ 10^-6 을 샘플링하지 말고, 10의 차수 값만 샘플링하는 것이 좋습니다.(-3 ~ -6)
        * learning rate는 gradient와 곱해지기 때문에, learning rate의 선택 범위를 log scale을 사용하는 편이 좋습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185526970-3a8aa0e5-3690-43a9-b1d3-ca50cb11d887.png">
</p>

* 앞에서 찾은 범위에서 다시 미세하게 찾아나갑니다.
* 위 슬라이드에서는 좋은 결과들을 빨간색 박스로 표시하였는데, 이들간의 learning rate에 큰 차이가 없는 범위내에서만 좋은 결과가 나오면 좋지 않다.(빨간글씨부분)
    * 저 범위 외에 더 좋은 값이 있을 수도 있기 때문입니다.
* 또한 다시 좁혀 설정한 범위의 경계부분에 집중되어 있다는 것을 알 수 있습니다.
    * 이렇게 되면 최적의 Learning rate를 효율적으로 탐색할 수 없을 수도 있습니다.
    * 실제로 최적의 값이 1E-5, 또는 1E-6 근처에 존재할 수도 있습니다.

<br>





# Random Search vs. Grid Search

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185526993-1d81ab29-2688-4303-9c5f-6e6bc5e751a4.png">
</p>

* Grid Search
    * 하이퍼파라미터를 특정 간격으로 샘플링해서 최적의 hyperparameter를 찾는 방법입니다.
* random search
    * 특정 범위 내에서 임의로 hyperparameter를 설정하고 비교하는 방법입니다.
* Hyperparameter를 탐색하는 방법은 위 슬라이드와 같이 2가지가 있는데, Grid Search에는 문제가 있습니다.
    * 실제로는 오른쪽 그림에서와 같이 여러 parameter들이 다차원의 형태로 존재합니다.
    * 따라서, 왼쪽 그림과 같이 grid로 탐색하게되면 9번을 하더라도 다른 차원에서는 3번밖에 searching을 수행하지 않은 결과가 나타날 수 있습니다.
* 따라서, random search 를 하면 모델의 성능이 어떤 파라미터에 대해 더 민감하게 반응하는지에 대해 알 수 있기 때문에, Random search가 더 좋은 방법입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185527024-723ea161-6c36-48e9-804b-cf2c1414879b.png">
</p>

* 여기서는 주로 learning rate를 다루었지만, 그 밖에 decay schedule, update type, regularization, network architecture, hidden unit과 depth의 수 등 이 모든 하이퍼파라미터를 전부 다 최적화 시킬 수 있으며, 모두 조정하면서 최적의 조합을 찾아야 합니다.
* 일종의 art...

<br>





# Monitor and visualize the loss curve

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185529702-b10d6a17-bf9b-4435-a8d3-504c1a0e9999.png">
</p>

* **<span style="background-color: #fff5b1">실제 cross validation으로 엄청나게 많은 하이퍼파라미터를 직접 돌려보고 모니터해서 어떤 값이 좋고 나쁜지를 확인해야 합니다.</span>**
* **<span style="color:red">Learning Curves</span>** 를 보면서, 좋은 것을 찾아서 시도해보는 일을 계속 반복해야 합니다.
* 슬라이드의 오른쪽 그래프에서, 빨간색 곡선이 이상적인 형태의 loss curve 입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185530083-7c983760-ce1a-4853-8502-4e768d64b0af.png">
</p>

* Loss값이 처음에 평평하다가 갑자기 감소하는 경우, Weight initialization이 잘못된 것을 나타내기에 weight initialization을 다시 시도해봐야 합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185530113-178f4f9a-e7a1-4c6b-99c2-a255574f2562.png">
</p>

* Loss값이 감소하다가 더 떨어질 가능성이 있지만 떨어지지 않는 경우에는, Learning rate decay를 시도해보면 됩니다. 

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185530126-b7efe559-cdc3-4658-842d-2d63dd70b0ff.png">
</p>

* 이 경우는 너무 빨리 LR를 줄여버린 경우입니다. Loss가 flat해지는 지점까지 기다렸다가 decay를 해보면 됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185530144-06ccbf70-51cd-4fc9-ace9-8e5d26b40c87.png">
</p>

* Iteratino에 따라서 Training/validation set의 accuracy를 찍어본 plot입니다.
* Training set과 val set의 accuracy가 같이 증가하며, 적당한 차이를 유지합니다.
* 즉, 위 그림처럼 train accuracy와 valid accuracy가 처음에 exponentially하게 증가하다 일정 gap을두며 linearly하게 천천히 증가한다면 잘 학습되고 있다는 뜻으로 더 길게 학습해야합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185530163-9273b4ee-109d-4949-8c08-dc71410578a9.png">
</p>

* 만약  Training set의 accuracy만 증가하고, val set의 accuracy는 어느 순간부터 낮아지기 시작하여, 두 선의 차이가 커진다면, 이는 곧 overfitting을 의미합니다.
* 이를 해결하기 위해서는, regularization을 세게 주거나, 데이터를 더 모아보는 방법이 있습니다. 이때, regularization을 세게 주는 것은, L2 regularization에서 람다를 크게 지정하는 것이나, data augmentation과 같은 방법을 의미합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185530199-8ebb50ae-fa0b-41fe-bd9a-53ef404d6ed3.png">
</p>

* Training set과 val set의 accuracy가 같이 증가하지만, 두 선의 차이가 너무 없다면, underfitting을 의심해보아야 합니다.
* 즉, bigger model 을 사용하거나, regularization을 줄여야 합니다.


<br>
<br>





# Track the ratio of weight updates / weight magnitudes:

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185544802-7b5c6788-b111-4ed4-a99c-97a9ca37fa4e.png">
</p>

* 학습 중에 W의 파라미터 크기와 업데이트될 값의 크기를 각각 norm 연산을 통해 구한 후, 이들의 비율을 계산하면 업데이트가 잘 수행되는지 확인할 수 있습니다.
    * Ex) 업데이트가 파라미터에 비해 너무 많이 수행된다면 ratio가 매우 클 것이고, 너무 적게 수행된다면 ratio가 매우 작을 것입니다.
* 이 방법은 학습에서 무엇이 문제가 되는지 확인하는 디버깅 용도로 사용 가능합니다.

<br>
<br>





# Summary

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/185545067-9e694dd0-6214-4efb-91b0-dc298a627cae.png">
</p>

* 각각의 주제에 명심해야할 내용입니다.
* 다음 강의에서 이어서 NN을 학습 시키는 데에 필요한 것들에 대해 더 알아보겠습니다.




