---
layout: post
title: OpenCV를 위한 NumPy
category: OpenCV
tag: OpenCV
---

[![Hits](https://hits.sh/museonghwang.github.io.svg?view=today-total&style=for-the-badge&label=Visitors&color=007ec6)](https://hits.sh/museonghwang.github.io/)

<br>

해당 게시물은 [파이썬으로 만드는 OpenCV 프로젝트(이세우 저)](https://github.com/dltpdn/insightbook.opencv_project_python/blob/master/README.md) 를 바탕으로 작성되었습니다.

<br>





# NumPy

NumPy는 OpenCV-Python 모듈의 필수 라이브러리기도 하지만, 데이터 과학 분야와 관련된 일을 파이썬 언어로 할 때 전반적으로 사용하는 라이브러리입니다.



## 1. 이미지와 NumPy

OpenCV에서 이미지나 동영상을 읽어들이는 함수 `cv2.imread()` 는 NumPy 배열을 반환합니다. 따라서 OpenCV를 파이썬 언어로 프로그래밍한다는 것은 NumPy 배열을 다룬다는 것과 같은 말입니다. 그만큼 NumPy에 대해 잘 알지 못하면 파이썬 언어로 OpenCV를 사용하는 게 불가능하다는 뜻이기도 합니다.

NumPy 배열에서 정보를 얻는 기본 속성은 다음과 같습니다.
* `ndim` : 차원(축)의 수
* `shape` : 각 차원의 크기(튜플)
* `size` : 전체 요소의 개수, shape의 각 항목의 곱
* `dtype` : 요소의 데이터 타입
* `itemsize` : 각 요소의 바이트 크기

이미지는 여러 개의 픽셀들의 값으로 구성되므로 수많은 행과 열로 구성된 픽셀 데이터의 모음이라고 볼 수 있습니다. 이 픽셀 데이터들을 프로그래밍 영역에서 다루려면 픽셀 값들을 저장하고 관리할 적절한 자료구조가 필요하기 마련입니다. OpenCV-Python은 예전에는 독자적인 자료구조를 사용했지만, 버전 2부터 NumPy라이브러리의 ndarray(N-Dimensional Array)를 가져다 쓰고 있습니다.

다음 코드는 파이썬 대화형 콘솔에서 OpenCV로 읽어들인 500 × 500 픽셀 이미지정보를 담은 NumPy 배열의 속성 정보를 출력합니다.

```py
import cv2

img = cv2.imread('./img/blank_500.jpg') # OpenCV로 이미지 읽기
print(type(img))    # img의 데이타 타입
print(img.ndim)     # 배열의 차원 수 
print(img.shape)    # 각 차원의 크기
print(img.size)     # 전체 요소의 갯수

[output]
<class 'numpy.ndarray'>
3
(500, 500, 3)
750000
```

ndarray는 N-Dimensional Array의 약자로 N차원 배열, 즉 다차원 배열을 의미합니다. OpenCV는 기본적으로 이미지를 3차원 배열, 즉 '행 × 열 × 채널'로 표현합니다. 행과 열은 이미지의 크기, 즉 높이와 폭만큼의 길이를 갖고 채널은 컬러인 경우 파랑, 초록, 빨강 3개의 길이를 갖습니다. 따라서 일반적인 이미지를 읽었을 때 3차원 배열은 '높이 x 폭 × 3'의 형태입니다.

위의 코드를 통해 3차원이고 배열이 500 × 500 × 3인 것을 확인할 수 있습니다. `img.size` 는 전체 요소의 개수로 각 차원의 길이를 곱한 값과 같습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/202898728-3772c642-ec6a-4e80-bfbd-49d161d1a63e.png">
</p>

파이썬 언어는 데이터 타입이나 데이터 크기를 따로 지정하지 않지만, 수많은 데이터를 처리해야 하는 NumPy 배열은 명시적인 데이터 타입을 지정하는 것이 효과적일 수밖에 없습니다. 이미지 픽셀 데이터는 음수이거나 소수점을 갖는 경우가 없고 값의 크기도 최대 255이므로 부호 없는 8비트, 그러니까 uint8을 데이터 타입으로 사용합니다. 다음과 같이 dtype 속성으로 데이터 타입을 확인할 수 있습니다.

```py
img = cv2.imread('./img/blank_500.jpg') # OpenCV로 이미지 읽기
print(img.dtype)    # 데이타 타입
print(img.itemsize) # 각 요소의 바이트 크기

[output]
uint8
1
```

`img.itemsize` 결과 값은 각 요소의 크기가 1바이트인 것을 나타냅니다.

NumPy 배열은 모든 요소에 동일한 연산을 수행하는 브로드캐스팅 연산, 선형대수학의 벡터와 행렬 연산, 푸리에 변환 등 이미지 프로세싱이나 컴퓨터 비전 분야에 활용할 수 있는 방대한 기능을 제공하므로 OpenCV 라이브러리의 도움 없이도 컴퓨터 비전 작업을 할 수 있을 정도입니다. 실제로 OpenCV의 함수와 NumPy의 함수 기능이 중복되는 것도 많습니다.

물론, 영상 처리와 컴퓨터 비전 알고리즘이 매우 복잡하고 구현하기 어렵기도 하고 자잘한 실수로 성능에 문제가 있는 경우도 많으므로 NumPy로 직접 구현하는 것보다는 최적화된 OpenCV 라이브러리를 쓰는 것이 효과적입니다. 하지만, OpenCV에 따로 구현되지 않은 간단한 연산은 NumPy 기능을 이용해서 직접 처리해야 하는 경우가 많으니 기초적인 NumPy 사용법은 반드시 알고 있어야 합니다.



## 2. NumPy 배열 생성

NumPy 배열을 만드는 방법은 값을 가지고 생성하는 방법과 크기만 지정해서 생성하는 방법으로 나눌 수 있습니다.

크기만 지정해서 생성하는 방법은 다시 특정한 초기 값을 모든 요소에 지정하는 경우와 값의 범위를 지정해서 순차적으로 증가 또는 감소하는 값을 갖게 하는 방법으로 나눌 수 있습니다.

다음 목록은 NumPy 배열 생성에 사용할 함수들입니다.
* 값으로 생성 : `array()`
* 초기 값으로 생성 : `empty()`, `zeros()`, `ones()`, `full()`
* 기존 배열로 생성 : `empty_like()`, `zeros_like()`, `ones_like()`, `full_like()`
* 순차적인 값으로 생성 : `arange()`
* 난수 생성 : `random.rand()`, `random.randn()`



## 3. 값으로 생성

배열 생성에 사용할 값을 가지고 있는 경우에는 `numpy.array()` 함수로 간단히 생성할 수 있습니다.

* `numpy.array(list [, dtype])` : 지정한 값들로 NumPy 배열 생성
    * `list` : 배열 생성에 사용할 값을 갖는 파이썬 리스트 객체
    * `dtype` : 데이터 타입(생략하면 값에 의해 자동 결정)
        * `int8`, `int16`, `int32`, `int64` : 부호 있는 정수
        * `uint8`, `uint16`, `uint32`, `uint64` : 부호 없는 정수
        * `float16`, `float32`, `float64`, `float128` : 부동 소수점을 갖는 실수
        * `complex64`, `complex128`, `complex256` : 부동 소수점을 갖는 복소수
        * `bool` : 불(boolean)

배열을 생성할 때 dtype을 지정하지 않으면 리스트의 항목 값에 따라 자동으로 결정됩니다. dtype 종류는 위에 나열한 것보다 많습니다. OpenCV에서 주로 사용하는 dtype은 uint8, int8, float32 정도가 전부이므로 굳이 모두 외울 필요는 없습니다.

이제 `numpy.array()` 함수로 파이썬 리스트에 값을 지정해서 생성하는 코드를 작성해 보겠습니다.

```py
import numpy as np

a = np.array([1,2,3,4])     # 정수를 갖는 리스트로 생성
b = np.array([[1,2,3,4],    # 2차원 리스트로 생성
              [5,6,7,8]])
c = np.array([1,2,3.14,4])  # 정수와 소수점이 혼재된 리스트
d = np.array([1,2,3,4], dtype=np.float32)   # dtype을 지정해서 생성

print(a, a.dtype, a.shape)  # ---①
print(b, b.dtype, b.shape)  # ---②
print(c, c.dtype, c.shape)  # ---③
print(d, d.dtype, d.shape)  # ---④

[output]
[1 2 3 4] int64 (4,)
[[1 2 3 4]
 [5 6 7 8]] int64 (2, 4)
[1.   2.   3.14 4.  ] float64 (4,)
[1. 2. 3. 4.] float32 (4,)
```

①, ②의 경우 배열을 생성할 때 dtype을 따로 지정하지 않았지만, 리스트 항목이 모두 정수라서 알아서 int64가 된 것을 볼 수 있습니다. 또한 ③의 경우 정수와 소수점이 있는 실수를 섞어서 배열을 만들었더니 dtype은 float64로 알아서 정해졌습니다. 그리고 ④는 정수만을 가지고 배열을 만들었지만 명시적으로 dtype=np.float32로 지정해서 데이터 타입이 float32 입니다.

명시적인 dtype을 지정해서 생성해야 할 때를 위해서 NumPy 생성함수는 dtype과 동일한 이름의 함수를 제공합니다. 예를 들어 dtype=np.uint8로 생성하려고 한다면 아래와 같이 할 수 있습니다.

```py
>>> a = np.uint8([1,2,3,4])
```



## 4. 크기와 초기 값으로 생성

우리는 NumPy 배열 생성에 사용할 값을 가지고 있지 않는 경우가 더 많습니다. 특히 이미지 작업을 할 때 픽셀 값을 타이핑해서 입력한다는 것은 거의 있을 수 없는 일입니다. NumPy 배열을 생성할 때 더 많이 사용하는 방법은 배열의 차수와 크기 그리고 초기 값을 지정해서 생성하는 방법입니다. 이때 쓸 수 있는 함수는 초기 값을 지정하는 방법에 따라 여러 가지가 있는데, 튜플로 차수와 크기를 지정하는 방법은 모두 같습니다.

* `numpy.empty(shape [, dtype])` : 초기화되지 않은 값(쓰레기 값)으로 배열 생성
    * `shape` : 튜플, 배열의 각 차수의 크기 지정
* `ndarray.fill(value)` : 배열의 모든 요소를 value로 채움
* `numpy.zeros(shape [, dtype])` : O(영, zero)으로 초기화된 배열 생성
* `numpy.ones(shape [, dtype])` : 1로 초기화된 배열 생성
* `numpy.full(shape, fill_value [, dtype])` : fill_value로 초기화된 배열 생성

아래 코드는 `numpy.empty()` 함수의 사용 사례를 보여주고 있습니다.

```py
import numpy as np

a = np.empty((2,3))
b = np.empty((2,3), dtype=np.int16)

print(a, a.dtype, a.shape)
a.fill(255)
print(a)
print(b, b.dtype, b.shape)

[output]
[[-1.28822975e-231 -2.68156180e+154  1.48219694e-323]
 [ 3.95252517e-323  1.18575755e-322  4.17201348e-309]] float64 (2, 3)
[[255. 255. 255.]
 [255. 255. 255.]]
[[3 0 0]
 [0 8 0]] int16 (2, 3)
```

위의 코드에서 보는 것처럼 2행 3열 배열이 만들어졌지만 초기 값은 제각각이고, dtype은 float64가 기본 값으로 사용된 것을 알 수 있습니다. 쓰레기 값을 갖는 배열이므로 어떤 값으로 초기화를 하고 싶으면 `fill()` 함수를 사용하는 것이 좋습니다.

이렇게 배열을 만들고 어떤 특정한 값으로 모든 요소를 초기화하는 일이 많을 텐데, 이런 작업을 한번에 해주는 함수가 `zeros()`, `ones()`, `full()` 입니다. 함수의 이름만 봐도 알 수 있듯이 초기화해 주는 값만 서로 다릅니다.

```py
import numpy as np

c = np.zeros((2,3))
d = np.zeros((2,3), dtype=np.int8)
e = np.ones((2,3), dtype=np.float32)
f = np.full((2,3,4), 255, dtype=np.uint8)

print(c, c.dtype, c.shape)
print(d, d.dtype, d.shape)
print(e, e.dtype, e.shape)
print(f, f.dtype, f.shape)

[output]
[[0. 0. 0.]
 [0. 0. 0.]] float64 (2, 3)
[[0 0 0]
 [0 0 0]] int8 (2, 3)
[[1. 1. 1.]
 [1. 1. 1.]] float32 (2, 3)
[[[255 255 255 255]
  [255 255 255 255]
  [255 255 255 255]]

 [[255 255 255 255]
  [255 255 255 255]
  [255 255 255 255]]] uint8 (2, 3, 4)
```

0(영)이나 1이 아닌 다른 원하는 초기 값을 지정하고 싶을 때는 앞의 코드처럼 `full()` 함수를 쓸 수 있습니다.

새로운 배열을 생성할 때 기존에 있던 배열과 같은 크기의 배열을 만들어야 할 때도 있는데, 그때 사용하는 함수는 다음과 같습니다.

* `empty_like(array [, dtype])` : 초기화되지 않은, array와 같은 shape와 dtype의 배열 생성
* `zeros_like(array [, dtype])` : O(영, zero)으로 초기화된, array와 같은 shape와 dtype의 배열 생성
* `ones_like(array [, dtype])` : 1로 초기화된, array와 같은 shape와 dtype의 배열 생성
* `full_like(array, fill_value [, dtype])` : fill_value로 초기화된, array와 같은 shape와 dtype의 배열 생성

주로 이미지를 읽어서 필요한 연산을 한 후에 결과 이미지를 생성할 때 원본 이미지와 동일한 크기의 배열을 생성해야 하는 경우가 많은데, 이때 이런 함수들을 자주 씁니다.

```py
import cv2
import numpy as np

img = cv2.imread('./img/girl.jpg')
print(img, img.shape, img.dtype)

[output]
[[[ 52  71  76]
  [ 47  68  70]
  [ 39  69  64]
  ...
  [ 24  72  54]
  [ 31  76  59]
  [ 35  80  63]]
  ...
  [223 193 206]
  [226 196 207]
  [229 199 210]]] (293, 406, 3) uint8
```

위 코드는 사진을 배열로 읽어들입니다. 이 이미지와 동일한 크기의 배열을 생성하는 코드를 작성하면 다음과 같습니다.

```py
import cv2
import numpy as np

img = cv2.imread('./img/girl.jpg')
a = np.empty_like(img)
b = np.zeros_like(img)
c = np.ones_like(img)
d = np.full_like(img, 255)
```

실행시켜보면 원본 이미지와 동일한 shape와 dtype을 갖지만 초기화된 값만 다릅니다.



## 5. 시퀀스와 난수로 생성

NumPy 배열을 생성하는 방법 중에는 일정한 범위 내에서 순차적인 값을 갖게 하는 방법과 난수로 채우는 방법이 있습니다.

* `numpy.arange([start=0, ] stop [, step=1, dtype=float64])` : 순차적인 값으로 생성
    * `start` : 시작 값
    * `stop` : 종료 값, 범위에 포함하는 수는 stop-1 까지
    * `step` : 증가 값
    * `dtype` : 데이터 타입.
* `numpy.random.rand([d0 [, d1 [..., dn]]])` : 0과 1사이의 무작위 수로 생성
    * `d0, d1..dn` : shape, 생략하면 난수 한 개 반환
* `numpy.random.randn([d0 [, d1 [..., dn]]])` : 표준정규분포(평균: 0, 분산: 1)를 따르는 무작위 수로 생성

`numpy.arange()` 함수는 파이썬 기본 함수인 `range()` 와 사용 방법이 거의 같습니다. 다만 이 함수는 리스트가 아닌 NumPy 배열을 반환한다는 차이가 있습니다.

```py
import numpy as np

a = np.arange(5)
print(a)
print(a.shape)
print(a.dtype)

[output]
[0 1 2 3 4]
(5,)
int64
```

숫자 하나를 인자로 전달하면 0부터 시작하는 값을 순차적으로 갖는 1차원 배열을 반환합니다. 이때 dtype은 요소들이 정수만으로 이루어졌으므로 int64를 갖습니다. 만약 아래의 코드처럼 인자로 소수점이 있는 수를 사용하면 dtype은 float64로 지정되며, 필요에 따라 명시적으로 지정할 수도 있습니다.

```py
import numpy as np

b = np.arange(5.0)
print(b)
print(b.shape)
print(b.dtype)

[output]
[0. 1. 2. 3. 4.]
(5,)
float64
```

이 함수는 시작 값과 종료 값 그리고 증가 값을 모두 지정해서 생성할 수도 있습니다. 반드시 기억해야 할 점은 지정한 범위의 마지막 값은 항목에 포함되지 않는다는 것입니다.

```py
>>> c = np.arange(3,9,2)
>>> c
array([3, 5, 7])
```

위 코드는 3에서 시작해서 9의 바로 앞 그러니까 8까지 2씩 증가하는 수를 갖는 배열을 생성합니다. `arange()` 함수는 1차원 배열만을 생성할 수 있으므로 다차원 배열, 특히 이미지 데이터를 갖는 3차원 배열로 만들기 위해서는 '차원 변경' 함수와 함께 써야 하는 경우가 많습니다.

난수를 발생하는 함수로는 `random.rand()` 와 `random.randn()` 이 있습니다. `rand()` 함수는 0과 1 사이의 값을 무작위로 만들고, `randn()` 함수는 평균이 0이고 분산이 1인 정규 분포를 따르는 무작위 수를 만들어 냅니다.

두 함수 모두 인자 없이 호출하면 난수 1개를 반환하고, 원하는 차수(shape)에 맞게 인자를 전달하면 해당 차수에 맞는 배열을 난수로 채워서 반환합니다.

```py
>>> np.random.rand()
0.29534415433963335
>>> np.random.randn()
0.881280912289447
>>> a = np.random.rand(2,3)
>>> a
array([[0.66166792, 0.03228477, 0.51420786],
       [0.48056368, 0.59934148, 0.26385163]])
>>> b = np.random.randn(2,3)
>>> b
array([[ 0.54229341, -1,40139248, 1.0294928 ],
       [ 3.0041478,  0.84068375, -0.24592442]])
```

위 코드의 a와 b 배열은 난수로 채워진 2행 3 열의 배열입니다.

이 함수들은 결과 값이 소수점을 갖는 데다가 특정 범위 내에서 난수를 추출하므로 이미지 작업에 필요한 원하는 범위 내에서 난수를 발생하기 위해서는 브로드캐스팅 연산과 dtype 변경이 필요할 때가 많습니다.



## 6. dtype 변경

배열의 데이터 타입을 변경하는 함수는 다음과 같습니다.

* `ndarray.astype(dtype)`
    * `dtype` : 변경하고 싶은 dtype, 문자열 또는 dtype
* `numpy.uintXX(array)` : array를 부호 없는 정수(uint) 타입으로 변경해서 반환
    * `uintXX` : uint8, unit 16, uint32, uint64
* `numpy.intXX(array)` : array를 int 타입으로 변경해서 반환
    * `intXX` : int8, int16, int32, int64
* `numpy.floatXX(array)` : array를 float 타입으로 변경해서 반환
    * `floatXX` : float16, float32, float64, float128
* `numpy.complexXX(array)` : array를 복소수(complex) 타입으로 변경해서 반환
    * `complexXX` : complex64, complex128, complex256

```py
import numpy as np

a = np.arange(5)
print(a, a.dtype)

b = a.astype('float32')
print(b, b.dtype)

[output]
[0 1 2 3 4] int64
[0. 1. 2. 3. 4.] float32
```

위 코드는 처음 int64 타입으로 생성한 배열을 float32로 변경하는 모습을 보여주고 있습니다. 이때 `astype('float32')` 함수에 전달한 인자는 문자열을 사용하고 있는데, 이것은 앞서 설명한 dtype 이름을 그대로 문자열로 작성하면 됩니다. 문자열에 오타가 있거나 일치하지 않는 경우 오류가 발생하니 주의해야 합니다.

아래 코드처럼 astype(np.float64) 함수에 NumPy 모듈에 선언된 변수를 이용하는 방법도 있습니다.
```py
import numpy as np

a = np.arange(5)
print(a, a.dtype)

c = a.astype(np.float64)
print(c, c.dtype)

[output]
[0 1 2 3 4] int64
[0. 1. 2. 3. 4.] float64
```

배열 객체의 dtype을 변경하는 방법으로는 배열 객체의 `astype()` 메서드를 호출하는방법이 있는 반면 또 다른 방법도 있습니다. NumPy 모듈 정적 함수에는 NumPy에서 지원하는 dtype들과 같은 이름의 함수들이 있는데, 이 함수들 중에 변경을 원하는 dtype 이름의 함수를 호출하면서 배열 객체를 인자로 전달하는 방법도 있습니다.

```py
import numpy as np

a = np.arange(5)
print(a, a.dtype)

d = np.uint8(a)
print(d, d.dtype)

[output]
[0 1 2 3 4] int64
[0 1 2 3 4] uint8
```

위 코드는 원래 데이터 타입이 int64였던 배열을 `np.uint8()` 함수에 전달했더니 uint8로 변경돼서 반환되는 것을 보여줍니다.



### 7. 차원 변경

원래는 1차원이던 배열을 2행 3열 배열로 바꾼다든지, 100 × 200 × 3인 배열을 1차원으로 바꾸는 식의 작업이 필요할 때가 많은데, 이때 필요한 함수는 다음과 같습니다.

* `ndarray.reshape(newshape)` : ndarray의 shape를 newshape로 차원 변경
* `numpy.reshape(ndarray, newshape)` : ndarray의 shape를 newshape로 차원 변경
    * `ndarray` : 원본 배열 객체
    * `newshape` : 변경하고자 하는 새로운 shape(튜플)
* `numpy.ravel(ndarray)` : 1차원 배열로 차원 변경
    * `ndarray` : 변경할 원본 배열
* `ndarray.T` : 전치배열(transpose)

앞서 살펴본 `numpy.arange()` 함수는 1차원 배열만을 생성할 수 있으므로 원하는 차원의 모양으로 변경하는 함수가 거의 대부분 필요합니다. 모양을 변경하는 함수는 원본 배열의 메서드로 호출하거나 NumPy 모듈에 있는 정적함수에 배열을 인자로 전달해서 호출합니다. 결과는 같으므로 그때그때 편리한 방법을 쓰면 됩니다.

```py
import numpy as np

a = np.arange(6)
b = a.reshape(2,3)
c = np.reshape(a, (2,3))

print(a, a.shape)
print(b, b.shape)
print(c, c.shape)

[output]
[0 1 2 3 4 5] (6,)
[[0 1 2]
 [3 4 5]] (2, 3)
[[0 1 2]
 [3 4 5]] (2, 3)
```

위 코드는 1차원 배열 a를 2행 3열로 바꾸는 작업을 두 가지 함수로 각각 보여주고 있습니다.

이 두 함수는 새로운 shape를 지정할 때 -1을 포함해서 전달할 수 있습니다. -1의 의미는 해당 차수에 대해서는 크기를 지정하지 않겠다는 뜻이고, 그것은 나머지 차수를 이용해서 알아서 계산해 달라는 뜻입니다.

```py
import numpy as np

d = np.arange(24).reshape(2,3,4)
e = np.arange(100).reshape(2, -1)
f = np.arange(100).reshape(-1, 5)

print(d, d.shape)
print(e, e.shape)
print(f, f.shape)

[output]
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]] (2, 3, 4)
[[ 0  1  2  ... 47 48 49]
 [50 51 52 ... 97 98 99]] (2, 50)
[[ 0  1  2  3  4]
 [ 5  6  7  8  9]
 ...
 [90 91 92 93 94]
 [95 96 97 98 99]] (20, 5)
```

위 코드는 100개의 1차원 배열의 차원을 변경하기 위해 지정한 shape에 -1을 쓴 예를 보여주고 있습니다. (2, -1)의 의미는 2행으로 나누고 열은 알아서 맞추라는 뜻입니다. 결국 100개의 요소를 2행으로 나누어 열이 50개가 되므로 2행 50열이 됩니다.

(-1, 5)는 -1행 5열을 생성하겠다는 것인데, 5열에 맞춰서 행을 알아서 계산하면 20행이 나오므로 (20, 5)가 출력됩니다. -1은 개발자에게 불필요한 계산을 하지 않아도 되게 해주므로 아주 편리합니다. 하지만 101개의 1차원 배열을 2열로 나누라는 식의 연산은 오류가 발생하므로 주의해야 합니다.

어떤 배열을 1차원 배열로 재정렬할 수 있는 방법은 방금 설명한 `reshape()` 함수를 이용해도 되고 `numpy.ravel()` 함수를 사용해도 됩니다.

```py
>>> f = np.zeros((2,3))
>>> f
array([[0., 0., 0.],
       [0., 0., 0.]])
>>> f.reshape((6,))
array([0., 0., 0., 0., 0., 0.])
>>> f.reshape(-1)
array([0., 0., 0., 0., 0., 0.])
>>> np.ravel(f)
array([0., 0., 0., 0., 0., 0.])
```

위 코드는 2행 3열 배열을 1차원 배열로 바꾸는 방법을 보여주고 있습니다. 첫 번째 방법은 `f.reshape((6,))` 과 같이 요소의 개수를 직접 전달하는 방법이며, 일일이 계산해야 하니 불편합니다. 그래서 조금 전 설명한 -1을 이용하면 간단히 해결할 수 있습니다. 마지막으로 `np.ravel()` 함수로도 똑같은 결과를 얻을 수 있습니다.

NumPy 배열(ndarray) 객체에는 `ndarray.T` 라는 속성이 있습니다. 이 속성을 이용하면 행과 열을 서로 바꾸는 전치배열을 얻을 수 있습니다.

```py
>>> g = np.arange(10).reshape(2,-1)
>>> g
array([[0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9]])
>>> g.T
array([[0, 5],
       [1, 6],
       [2, 7],
       [3, 8],
       [4, 9]])
```



## 8. 브로드캐스팅 연산

아마도 NumPy 배열을 사용하는 가장 큰 이유는 브로드캐스팅(broadcasting) 연산 때문일 것입니다. 다음 코드의 예처럼 0부터 9까지 있는 파이썬 리스트의 모든 항목 값을 1씩 증가시키려면 반복문을 작성해야 합니다.

```py
import numpy as np

mylist = list(range(10))
print(mylist)

for i in range(len(mylist)):
    mylist[i] = mylist[i] + 1
print(mylist)

[output]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
```

하지만, NumPy 배열에 +1(더하기 1) 연산을 한 번만 해도 같은 결과를 얻게 되는데, 이것을 브로드캐스팅 연산이라고 합니다.

```py
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a + 1
array([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
```

브로드캐스팅 연산은 더하기 연산뿐만 아니라 모든 산술 연산이 가능합니다. 아래코드는 NumPy 배열과 스칼라(Scalar, 스케일러) 값 간의 여러 가지 연산의 예를 보여주고 있습니다.

```py
>>> a = np.arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> a + 5
array([5, 6, 7, 8, 9])
>>> a - 2
array([-2, -1, 0, 1, 2])
>>> a * 2
array([0, 2, 4, 6, 8])
>>> a / 2
array([0., 0.5, 1., 1.5, 2. ])
>>> a ** 2
array([ 0, 1, 4, 9, 16])
>>> b = np.arange(6).reshape(2, -1)
>>> b
array([[0, 1, 2],
       [3, 4, 5]])
>>> b * 2
array([[ 0, 2,  4],
       [ 6, 8, 10]])
```

다차원 배열에도 똑같이 연산이 적용되는 것을 알 수 있습니다.

산술 연산뿐만 아니라 비교 연산도 가능합니다. 비교 연산의 결과는 각 항목에 대해 만족 여부를 불값(True/False)으로 갖는 동일한 크기의 배열로 반환합니다.

```py
>>> a
array([0, 1, 2, 3, 4])
>>> a > 2
array([False, False, False, True, True])
```

배열과 숫자 값 간의 연산뿐만 아니라 배열끼리의 연산도 가능합니다.

```py
>>> a = np.arange(10, 60, 10)
>>> b = np.arange(1, 6)
>>> a
array([10, 20, 30, 40, 50])
>>> b
array([1, 2, 3, 4, 5])
>>> a + b
array([11, 22, 33, 44, 55])
>>> a - b
array([ 9, 18, 27, 36, 45])
>>> a * b
array([ 10, 40, 90, 160, 250])
>>> a / b
array([10., 10., 10., 10., 10.])
>>> a ** b
array([ 10, 400, 27000, 2560000, 312500000])
```

하지만, 배열 간의 연산에는 약간의 제약이 있습니다. 두 배열의 shape가 완전히 동일하거나 둘 중 하나가 1차원이면서 1차원 배열의 축의 길이가 같아야 합니다.

```py
>>> a = np.ones((2,3))
>>> b = np.ones((3,2))
>>> a + b
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ValueError: operands could not be broadcast together with shapes (2,3) (3,2)
```

위 코드는 두 배열의 shape가 일치하지 않아서 연산에 실패합니다.

```py
>>> a
array([[1., 1., 1.],
       [1., 1., 1.]])
>>> c = np.arange(3)
>>> c
array([0, 1, 2])
>>> a + c
array([[1., 2., 3.],
       [1., 2., 3.]])
```

위 코드는 배열 c가 1차원이고 1차원 배열의 열의 개수가 a 배열의 열의 개수와 같아서 연산이 가능합니다. 만약 1차원 배열이라고 해도 열의 개수가 맞지 않으면 아래 코드처럼 연산은 실패합니다.

```py
>>> d = np.arange(2)
>>> a + d
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
ValueError: operands could not be broadcast together with shapes (2,3) (2,)
```

이 경우 열 단위 연산을 하려면 배열 d의 모양을 바꾸어 연산할 수 있습니다.

```py
>>> a
array([[1., 1., 1.],
       [1., 1., 1.]])
>>> d = np.arange(2).reshape(2,1)
>>> d
array([[0],
       [1]])
>>> a + d
array([[1., 1., 1.],
       [2., 2., 2.]])
```

NumPy 배열의 연산은 수학에서의 행렬과 벡터의 연산과 비슷해 보이지만 배열의 곱셈 연산은 행렬 연산과는 다르니 주의해야합니다.



## 9. 인덱싱과 슬라이싱

NumPy 배열은 파이썬의 리스트처럼 인덱스로 각 요소에 접근할 수 있습니다. 당연히 배열의 차원에 따라서 인덱스의 개수도 달라집니다.

```py
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a[5]
5
>>> b = np.arange(12).reshape(3,4)
>>> b
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> b[1]
array([4, 5, 6, 7])
>>> b[1, 2]
6
```

위 코드에서 배열 a는 1차원, b는 2차원입니다. 이때 2차원인 배열 b에 1개의 인덱스만 사용하면 1개의 행 모두가 선택됩니다. 2차원일 때는 인덱스 2개를 사용해서 열과 행을 지정해야 1개의 요소를 선택할 수 있습니다.

```py
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a[5] = 9
>>> a
array([0, 1, 2, 3, 4, 9, 6, 7, 8, 9])
>>> b
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> b[0] = 0
>>> b
array([[ 0,  0,  0,  0],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> b[1,2] = 99
>>> b
array([[ 0,  0,  0,  0],
       [ 4,  5, 99,  7],
       [ 8,  9, 10, 11]])
```

위 코드에서 보여주는 것처럼 값의 변경도 마찬가지로 인덱스로 정확히 1개의 요소를 지정하면 1개의 요소만 변경되지만, 인덱스를 적게 지정해서 행 단위로 지정하면 브로드캐스팅 연산이 일어나서 해당 단위 모두를 같은 값으로 변경합니다.

인덱스 자리에 콜론(:)을 이용해서 범위를 지정하면 슬라이싱(slicing)을 할 수 있습니다. 이때 범위의 끝 인덱스는 슬라이싱 결과에 포함되지 않습니다. 시작과 끝 인덱스를 각각 생략하면 처음부터 끝까지라는 의미입니다.

```py
>>> a = np.arange(10);
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a[2:5]
array([2, 3, 4])
>>> a[5:]
array([5, 6, 7, 8, 9])
>>> a[:]
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> b = np.arange(12).reshape(3,4)
>>> b
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> b[0:2, 1]
array([1, 5])
>>> b[0:2, 1:3]
array([[1, 2],
       [5, 6]])
>>> b[2, :]
array([ 8, 9, 10, 11])
>>> b[:, 1]
array([1, 5, 9])
>>> b[0:2, 1:3] = 0
array([[ 0,  0,  0,  3],
       [ 4,  0,  0,  7],
       [ 8,  9, 10, 11]])
```

b[0:2, 1]은 b 배열 0~1행의 1열 요소들을 의미하고, b[0:2, 1:3]은 b 배열 0~1행의 1~2열 요소들을 의미합니다.

값의 할당은 앞서 살펴본 것처럼 브로드캐스팅 연산으로 이루어집니다. 파이썬 기본형인 리스트와의 가장 큰 차이점은 슬라이싱의 결과가 복제본이 아닌 원본 이라는것입니다. 흔히 다음 코드와 같이 슬라이싱으로 전체 배열 중 일부를 다른 변수에 할당하는 경우 별도의 배열로 착각하는 경우가 많습니다. 그러나 이는 슬라이싱 해당영역에 대한 참조일 뿐 값의 변경은 원본에도 그대로 반영됩니다.

```py
>>> b
array([[ 0,  0,  0,  3],
       [ 4,  0,  0,  7],
       [ 8,  9, 10, 11]])
>>> bb = [0:2, 1:3]
>>> bb
array([[0, 0],
       [0, 0]])
>>> bb[0] = 99
>>> b
array([[ 0, 99, 99,  3],
       [ 4,  0,  0,  7],
       [ 8,  9, 10, 11]])
```

만약 파이썬 리스트처럼 복제본을 얻고 싶다면 `ndarray.copy()` 함수를 명시적으로 호출해야 합니다.



## 10. 팬시 인덱싱

배열 인덱스에 다른 배열을 전달해서 원하는 요소를 선택하는 방법을 팬시 인덱싱(fancy indexing)이라고 합니다. 전달하는 배열에 숫자를 포함하고 있으면 해당 인덱스에 맞게 선택되고, 배열에 불(boolean) 값을 포함하면 True인 값을 갖는 요소만 선택됩니다.

```py
>>> a = np.arange(5)
>>> a
array([0, 1, 2, 3, 4])
>>> a[[1, 3]]
array([1, 3])
>>> a[[True, False, True, False, True]]
array([0, 2, 4])
```

NumPy 배열에 비교 연산을 하면 개별 요소들이 조건을 만족하는지를 알 수 있습니다. 반대로 불 값을 갖는 배열을 배열의 인덱스 대신 사용하면 True 값 위치의 값들만 얻을 수 있는데, 이 둘을 한번에 합해서 실행하면 원하는 조건의 값만을 얻을 수 있습니다.

```py
>>> a = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> b = a > 5
>>> b
array([False, False, False, False, False, False, True, True, True, True])
>>> a[b]
array([6, 7, 8, 9])
>>> a[a>5]
array([6, 7, 8, 9])
>>> a[a>5] = 1
>>> a
array([0, 1, 2, 3, 4, 5, 1, 1, 1, 1])
```

이때에도 새로운 값을 지정하면 브로드캐스팅 연산으로 해당 요소들 모두의 값을 바꿀 수 있습니다.

다차원인 경우 인덱스 배열도 다차원으로 지정할 수 있고, 이때는 교차하는 인덱스의 것이 선택됩니다.

```py
>>> b = np.arange(12).reshape(3,4)
>>> b
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> b[[0,2]]
array([[ 0,  1,  2,  3],
       [ 8,  9, 10, 11]])
>>> b[[0,2], [2,3]]
array([2, 11])
```



## 11. 병합과 분리

2개 이상의 NumPy 배열을 병합하는 방법은 크게 두 가지가 있습니다. 단순히 배열들을 이어 붙여서 크기를 키우는 방법과 새로운 차원을 만들어 서로서로 끼워넣는 방법입니다.

여기서부터는 축(axis)이라는 용어를 꼭 알아야 합니다. NumPy 배열의 shape 속성을 확인하면 튜플 형식으로 몇 개의 숫자가 나오는 것은 이미 알아보았습니다. 각 숫자의 개수는 차원을 의미하며, 맨 앞부터 0, 1, 2,... 순으로 축 번호를 사용합니다. 예를 들어 어느 배열의 shape가 (10,20,3)이면 3개의 축이 있고 10은 0번 축, 20은 1번 축, 3은 2번 축을 나타냅니다. 축을 기준으로 작업을 한다는 뜻은 바로 shape의 각 순서에 따라 작업을 한다는 뜻입니다.

여기서 알아볼 병합에 사용하는 함수는 다음과 같습니다.

* `numpy.hstack(arrays)` : arrays 배열을 수평으로 병합
* `numpy.vstack(arrays)` : arrays 배열을 수직으로 병합
* `numpy.concatenate(arrays, axis=0)` : arrays 배열을 지정한 축 기준으로 병합
* `numpy.stack(arrays, axis=0)` : arrays 배열을 새로운 축으로 병합
    * `arrays` : 병합 대상 배열(튜플)
    * `axis` : 작업할 대상 축 번호

위 함수 중에 일단 가장 손쉽게 쓸 수 있는 함수는 `numpy.vstack()` 과 `numpy.hstack()` 입니다.

```py
>>> a = np.arange(4).reshape(2,2)
>>> a
array([[0, 1],
       [2, 3]])
>>> b = np.arange(10, 14).reshape(2,2)
>>> b
array([[10, 11],
       [12, 13]])
>>> np.vstack((a,b))
array([[ 0,  1],
       [ 2,  3],
       [10, 11],
       [12, 13]])
>>> np.hstack((a,b))
array([[0, 1, 10, 11],
       [2, 3, 12, 13]])
>>> np.concatenate((a,b), 0)
array([[ 0,  1],
       [ 2,  3],
       [10, 11],
       [12, 13]])
>>> np.concatenate((a,b), 1)
array([[ 0, 1, 10, 11],
       [ 2, 3, 12, 13]])
```

위 코드는 2행 2열인 배열 a와 b를 `numpy.vstack()` 으로 수직 병합해서 4행 2열 배열로 만들고, `numpy.hstack()` 으로 수평 병합해서 2행 4열 배열로 만듭니다. `numpy.vstack()` 함수는 수직으로 배열을 병합하는데, `numpy.concatenate()` 함수에 축 번호로 0을 지정해서도 같은 결과를 얻을 수 있습니다. 2개의 (2,2) 배열의 0번 축 방향 그러니까 행 방향으로 병합하므로 (4,2)가 되게 하는 것입니다. `hstack()` 함수는 수평으로 배열을 병합하는데, `concatenate()` 함수에 축 번호로 1을 지정해서도 (2,4) 크기의 배열을 얻을 수 있습니다.

`numpy.stack()` 함수는 차원(축)이 새로 늘어나는 방법으로 병합을 하는데, 축 번호를 지정하지 않으면 0번을 의미하고, -1은 마지막 축 번호를 의미합니다.

```py
>>> a = np.arange(12).reshape(4,3)
>>> b = np.arange(10, 130, 10).reshape(4,3)
>>> a
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])
>>> b
array([[ 10, 20, 30],
       [ 40, 50, 60],
       [ 70, 80, 90],
       [100, 110, 120]])
>>> c = np.stack((a,b), 0)
>>> c.shape
(2, 4, 3)
>>> c
array([[[ 0,  1,  2],
        [ 3,  4,  5],
        [ 6,  7,  8],
        [ 9, 10, 11]],
        
       [[ 10, 20, 30],
        [ 40, 50, 60],
        [ 70, 80, 90],
        [100, 110, 120]]])
```

위 코드는 (4,3) 배열 2개를 `np.stack((a, b), 0)` 함수로 병합하고 있으므로 원래 4행 3열인 2차원 배열은 병합하고 나면 3차원이 되고 축 번호도 0, 1, 2로 3개가 됩니다. 이때 축 번호로 0을 전달하므로 맨 앞 축 번호가 새로 생성되어 (2, 4, 3)인 배열이 만들어집니다. 이때 축 번호를 생략하면 0과 같습니다.

다음은 같은 배열을 축 번호 1과 2로 각각 생성한 코드입니다.

```py
>>> d = np.stack((a,b), 1)
>>> d.shape
(4, 2, 3)
>>> d
array([[[  0,   1,   2],
        [ 10,  20,  30]],
        
       [[  3,   4,   5],
        [ 40,  50,  60]],
        
       [[  6,   7,   8],
        [ 70,  80,  90]],
        
       [[  9,  10,  11],
        [100, 110, 120]]])
>>> e = np.stack((a,b), 2)
>>> e.shape
(4, 3, 2)
>>> e
array([[[ 0, 10],
        [ 1, 20],
        [ 2, 30]],

       [[ 3, 40],
        [ 4, 50],
        [ 5, 60]],
        
       [[ 6, 70],
        [ 7, 80],
        [ 8, 90]],
        
       [[ 9, 100],
        [10, 110],
        [11, 120]]])
>>> ee = np.stack((a,b), -1)
>>> ee.shape
(4, 3, 2)
```

위 코드는 앞서 사용했던 코드에서 (4,3) 인 배열 a와 b를 병합합니다. `np.stack((a,b), 1)` 로 병합할 때 전달한 축 번호는 1이므로 새로운 축은 1번 축에 추가되어 (4,2,3)이 되고, `np.stack((a,b), 2)` 로 병합할 때 축 번호는 2이므로 새로운 축은 2번 축에 추가되어 (4,3,2)가 됩니다. 이때 축 번호로 -1을 전달하면 마지막 축 번호,즉 여기서는 2와 같은 의미를 갖습니다.

이 함수들은 이미지 작업을 완료하고 작업 전과 후 이미지를 병합해서 나란히 출력할 때 자주 씁니다.

배열을 분리할 때 사용하는 함수는 아래와 같습니다.

* `numpy.vsplit(array, indice)` : array 배열을 수평으로 분리
* `numpy.hsplit(array, indice)` : array 배열을 수직으로 분리
* `numpy.split(array, indice, axis=0)` : array 배열을 axis 축으로 분리
    * `array` : 분리할 배열
    * `indice` : 분리할 개수 또는 인덱스
    * `axis` : 기준 축 번호

`indice` 는 어떻게 나눌지를 정하는 인자인데, 정수 또는 1차원 배열을 사용할 수 있습니다. 정수를 전달하면 배열을 그 수로 나누고, 1차원 배열을 전달하면 나누고자 하는 인덱스로 사용합니다. `indice` 인자의 사용 예를 들면 아래와 같습니다.

```py
>>> a = np.arange(12)
>>> a
array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
>>> np.hsplit(a, 3)
[array([0, 1, 2, 3]), array([4, 5, 6, 7]), array([ 8, 9, 10, 11])]
>>> np.hsplit(a, [3,6])
[array([0, 1, 2]), array([3, 4, 5]), array([ 6, 7, 8, 9, 10, 11])]
>>> np.hsplit(a, [3,6,9])
[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8]), array([ 9, 10, 11])]
>>> np.split(a, 3, 0)
[array([0, 1, 2, 3]), array([4, 5, 6, 7]), array([ 8, 9, 10, 11])]
>>> np.split(a, [3,6,9], 0)
[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8]), array([ 9, 10, 11])]
```

위 코드에서 `np.hsplit(a, 3)` 은 12개의 요소를 갖는 배열을 수평으로 분리하는데,indice 항목에 3이 전달되었으므로 배열을 3개로 쪼개어 각 배열은 4개 요소씩 갖습니다.

`np.hsplit(a, [3,6])` 은 3과 6을 배열로 표시했기 때문에 인덱스로 사용합니다. 이것은 [0:3], [3:6], [6:]과 같은 의미입니다. 위 코드에서처럼 나누고 싶은 구역의 인덱스를 좀 더 자세히 전달하려면 `np.hsplit(a, [3,6,9])` 와 같이 전달할 수도 있습니다.

위 코드에서는 1차원 배열을 사용했으므로 `numpy.hsplit()` 함수만 사용할 수 있습니다. 1차원인 경우 축 번호도 1개, 즉 0만 사용할 수 있으므로 `numpy.split()` 함수에서도 축(axis)에 사용할 수 있는 값은 0뿐이며, 같은 결과를 반환합니다.

```py
>>> b = np.arange(12).reshape(4,3)
>>> b
array([[ 0,  1,  2],
       [ 3,  4,  5],
       [ 6,  7,  8],
       [ 9, 10, 11]])
>>> np.vsplit(b, 2)
[array([[ 0,  1,  2], [ 3,  4,  5]]),
 array([[ 6,  7,  8], [ 9, 10, 11]])]
>>> np.split(b, 2, 0)
[array([[ 0,  1,  2], [ 3,  4,  5]]),
 array([[ 6,  7,  8], [ 9, 10, 11]])]
>>> np.hsplit(b, [1])
[array([[0], [3], [6], [9]]),
 array([[ 1, 2], [ 4, 5], [ 7, 8], [10, 11]])]
>>> np.split(b, [1], 1)
[array([[0], [3], [6], [9]]),
 array([[ 1, 2], [ 4, 5], [ 7, 8], [10, 11]])]
```

위 코드는 나누려는 배열이 2차원일 때 `numpy.vsplit()` 를 사용한 것과 `numpy.split()` 에 축 번호 0을 지정했을 때 같은 결과가 나오는 것을 보여주고 있습니다. 배열의 shape가 (4,3)이므로 `vsplit(b, 2)` 는 수직으로 나누어 4행을 2로 나누어 2행씩 갖게하고, `split(b, 2, 0)` 함수는 0번 축을 기준으로 2로 나누게 됩니다.

4행 3열 배열을 수평으로 나누는 것은 1번 축으로 나누는 것입니다. 3을 2로 나눌수 없으므로 특정 인덱스로 지정해서 나눠보면 indice 인자에 [1]을 지정한 것은 [1:]과 같고 `numpy.hsplit()` 함수를 쓴 것과 `numpy.split()` 함수에 1을 전달한 결과는 같습니다.



### 12. 검색

NumPy 배열을 사용하는 이유는 수많은 데이터를 쉽고 빠르게 다루려는 이유가 가장 크며, 이미지 작업도 마찬가지입니다. 그래서 NumPy를 쓰다 보면 배열 안에서 관심 있는 데이터만을 찾거나 찾아서 바꾸는 일이 자주 필요합니다. 이와 관련한 함수는 다음과 같습니다.

* `ret = numpy.where(condition [, t, f])` : 조건에 맞는 요소를 찾기
    * `ret` : 검색 조건에 맞는 요소의 인덱스 또는 변경된 값으로 채워진 배열(튜플)
    * `condition` : 검색에 사용할 조건식
    * `t, f` : 조건에 따라 지정할 값 또는 배열, 배열의 경우 조건에 사용한 배열과 같은 shape
        * `t` : 조건에 맞는 값에 지정할 값이나 배열
        * `f` : 조건에 틀린 값에 지정할 값이나 배열
* `numpy.nonzero(array)` : array에서 요소 중에 0(영, zero)이 아닌 요소의 인덱스들을 반환(튜플)
* `numpy.all(array [, axis])` : array의 모든 요소가 True인지 검색
    * `array` : 검색 대상 배열
    * `axis` : 검색할 기준 축, 생략하면 모든 요소 검색, 지정하면 축 개수별로 결과 반환
* `numpy.any(array [, axis])` : array의 어느 요소이든 True가 있는지 검색

아래 코드는 배열에서 조건에 맞는 인덱스를 찾아오는 사례, 그리고 찾은 값을 새로운 값으로 변경한 배열을 구하는 사례를 보여줍니다.

```py
>>> a = np.arange(10, 20)
>>> a
array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
>>> np.where(a > 15)
(array([6, 7, 8, 9]),)
>>> np.where(a > 15, 1, 0)
array([0, 0, 0, 0, 0, 0, 1, 1, 1, 1])
>>> a
array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
```

위 코드 `np.where(a > 15)` 는 10부터 19까지 값을 갖는 배열 a에서 15보다 큰 값을 갖는 요소의 인덱스를 구합니다. `np.where(a > 15, 1, 0)` 은 15보다 큰 값을 1로 채우고 그렇지 않은 값은 0으로 채운 새로운 배열을 구합니다.

만약 조건에 맞는 요소만 특정한 값으로 변경하고 맞지 않는 요소는 기존 값을 그대로 갖게 하려면 다음과 같은 코드로 할 수 있습니다.

```py
>>> a
array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
>>> np.where(a > 15, 99, a)
array([10, 11, 12, 13, 14, 15, 99, 99, 99, 99])
>>> np.where(a > 15, a, 0)
array([0, 0, 0, 0, 0, 0, 16, 17, 18, 19])
>>> a
array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
```

위 코드는 조건에 맞거나 틀린 경우에 할당할 값으로, 원래의 검색 대상 배열을 그대로 지정해서 조건에 맞는 값만 새로운 값으로 지정하거나 그 반대로도 가능합니다. 결과는 새로운 배열을 반환하므로 원본 배열은 그대로 유지됩니다.

다차원 배열인 경우 원하는 요소를 검색만 한다면 해당하는 요소의 인덱스는 여러 개를 반환합니다.

```py
>>> b = np.arange(12).reshape(3,4)
>>> b
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> coords = np.where(b>6)
>>> coords
(array([1, 2, 2, 2, 2]), array([3, 0, 1, 2, 3]))
>> np.stack((coords[0], coords(1)), -1)
array([[1, 3],
       [2, 0],
       [2, 1],
       [2, 2],
       [2, 3]])
```

위 코드는 3행 4열의 배열에서 6보다 큰 수만 검색하는 코드인데, 검색 결과는 행 번호(axis=0)만 갖는 배열과 열 번호(axis=1)만 갖는 배열 2개를 반환합니다. 이때 따로 떨어진 2개의 배열을 짝지어진 좌표 (x,y) 모양으로 얻으려면 앞서 살펴본 `stack()` 함수를 이용해서 병합하면 됩니다. 위 코드 `np.stack((coords[0], coords[1]), -1)` 에서 -1은 1로 바꾸어도 같습니다.

배열 요소 중에 0(zero)이 아닌 요소를 찾을 때는 `numpy.nonzero()` 함수를 사용할 수 있습니다. 이 함수는 0이 아닌 요소의 인덱스를 배열로 만들어서 반환합니다.

```py
>>> z = np.array([0,1,2,0,1,2])
>>> np.nonzero(z)
(array([1, 2, 4, 5]),)
>>> zz = np.array([[0,1,2], [1,2,0], [2,0,1]])
>>> zz
array([[0, 1, 2],
       [1, 2, 0],
       [2, 0, 1]])
>>> coords = np.nonzero(zz)
>>> coords
(array([0, 0, 1, 1, 2, 2]), array([1, 2, 0, 1, 0, 2]))
>>> np.stack((coords[0], coords[1]), -1)
array([[0, 1],
       [0, 2],
       [1, 0],
       [1, 1],
       [2, 0],
       [2, 2]])
```

다차원 배열인 경우 `numpy.where()` 함수와 마찬가지로 차원 수만큼의 배열로 반환하므로 앞서 설명한 방법대로 필요에 따라 `numpy.stack()` 함수로 병합하여 좌표 꼴로 만들 수 있습니다.

`numpy.nonzero()` 함수는 True나 False 같은 불 값에 대해서는 False를 O(영, zero)으로 간주하고 동작하므로 `numpy.where()` 함수처럼 조건을 만족하는 요소의 인덱스를 찾을 수도 있습니다.

```py
>>> a
array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19])
>>> np.nonzero(a>15)
(array([6, 7, 8, 9]),)
>>> np.where(a>15)
(array([6, 7, 8,9]),)
>>> b
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
np.nonzero(b>6)
(array([1, 2, 2, 2, 2]), array([3, 0, 1, 2, 3]))
>>> np.where(b>6)
(array([1, 2, 2, 2, 2]), array([3, 0, 1, 2, 3]))
```

NumPy 배열에 모든 요소가 참 또는 거짓인지 확인할 때는 `all()` 함수를 사용할 수 있습니다.

```py
>>> t = np.array([True, True, True])
>>> np.all(t)
True
>>> t[1] = False
>>> t
array([ True, False, True])
>>> np.all(t)
False
```

위 코드에서 배열의 모든 요소가 True일 때는 `np.all(t)` 가 True를 반환하지만 1개의 요소를 False로 바꾸자 그 결과가 False로 나타나는 것을 보여줍니다.

```py
>>> tt = np.array([[True, True], [False, True], [True, True]])
>>> tt
array([[ True, True],
       [False, True],
       [ True, True]])
>>> np.all(tt, 0)
array([False, True])
>>> np.all(tt, 1)
array([True, False, True])
```

`all()` 함수에 축(axis) 인자를 지정하지 않으면 모든 요소에 대해서 True를 만족하는지 검색하지만, 축 인자를 지정하면 해당 축을 기준으로 True를 만족하는지 반환합니다.

NumPy 배열에 조건식 연산을 하면 True, False를 갖는 배열이 생성되는 것을 앞서 "연산"에서 살펴보았습니다. 이것을 `numpy.all()` 과 `numpy.where()` 함수를 이용하면 2개의 배열이 서로 같은지 다른지, 다르다면 어느 항목이 다른지를 찾을 수 있습니다.

```py
>>> a = np.arange(10)
>>> b = np.arange(10)
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> b
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> a==b
array([ True, True, True, True, True, True, True, True, True, True])
>>> np.all(a==b)
True
>>> b[5] = -1
>>> a
array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
>>> b
array([0, 1, 2, 3, 4, -1, 6, 7, 8, 9])
>>> np.all(a==b)
False
>>> np.where(a==b)
(array([0, 1, 2, 3, 4, 6, 7, 8, 9]),)
>>> np.where(a!=b)
(array([5]), )
```

위 코드에서 배열 a와 b는 처음에는 동일하지만 b[5] = -1 연산으로 다르게 했습니다. `np.all(a==b)` 연산으로 두 배열이 서로 같은 값으로 채워졌는지 아닌지를 확인할 수 있고, 만약 아니라면 `np.where(a!=b)` 로 다른 요소의 인덱스를 찾을 수 있습니다.

이미지 작업에서는 이전 프레임과 다음 프레임 간의 픽셀 값의 변화가 있는지, 변화가 있는 픽셀의 위치가 어디인지를 찾는 방법으로 움직임을 감지하거나 객체 추적과 같은 작업을 하는 데 이 함수들을 사용합니다.



## 13. 기초 통계 함수

배열의 값이 하나하나를 확인할 수 없을 만큼 많을 때는 평균, 최대 값, 최소 값 같은 통계값들이 의미 있는 정보가 될 때가 많습니다. 대표적인 함수는 다음과 같습니다.

* `numpy.sum(array [, axis])` : 배열의 합계 계산
* `numpy.mean(array [, axis])` : 배열의 평균 계산
* `numpy.amin(array [, axis])` : 배열의 최소 값 계산
* `numpy.min(array [, axis])` : numpy.amin()과 동일
* `numpy.amax(array [, axis])` : 배열의 최대 값 계산
* `numpy.max(array [, axis])` : numpy.amax()와 동일
    * `array` : 계산의 대상 배열
    * `axis` : 계산 기준 축, 생략하면 모든 요소를 대상

```py
>>> a = np.arange(12).reshape(3, 4)
>>> a
array([[ 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11]])
>>> np.sum(a)
66
>>> np.sum(a, 0)
array([12, 15, 18, 21])
>>> np.sum(a, 1)
array([ 6, 22, 38])
```

위 코드는 0부터 11까지 값으로 갖는 배열을 3행 4열로 만들었습니다. `np.sum(a)` 함수는 모든 요소 값의 합계를 내줍니다. 축 번호를 지정하면 행과 열을 기준으로 각각 합산하는 것을 알 수 있습니다.

다음 코드는 같은 방법으로 평균, 최소 값, 최대 값을 각각 구하고 있습니다.

```py
>>> np.mean(a)
5.5
>>> np.mean(a, 0)
array([4., 5., 6., 7.])
>>> np.mean(a, 1)
array([1.5, 5.5, 9.5])
>>> np.amin(a)
0
>>> np.amin(a, 0)
array([0, 1, 2, 3])
>>> np.amin(a, 1)
array([0, 4, 8])
>>> np.amax(a)
11
>>> np.amax(a, 0)
array([ 8, 9, 10, 11])
>>> np.amax(a, 1)
array([ 3, 7, 11])
```

다음 코드는 `amin()` 과 `min()`, `amax()` 와 `max()` 함수가 내부적으로 동일하다는 것을 보여주고 있습니다. 따라서 각각의 함수는 어느 것을 사용하든 차이가 없습니다.

```py
>>> np.amin is np.min
True
>>> np.max is np.amax
True
```



## 14. 이미지 생성

지금까지 NumPy를 사용하기 위한 기본적인 내용을 살펴보았습니다. 다음 코드는 지금까지 다룬 지식으로 간단한 이미지를 생성해 보는 사례입니다.

```py
'''NumPy 배열로 체크무늬 그레이 스케일 이미지 생성(np_gray.py)'''
import cv2
import numpy as np

img = np.zeros((120,120), dtype=np.uint8)   # 120x120 2차원 배열 생성, 검은색 흑백 이미지
img[25:35, :] = 45                          # 25~35행 모든 열에 45 할당
img[55:65, :] = 115                         # 55~65행 모든 열에 115 할당
img[85:95, :] = 160                         # 85~95행 모든 열에 160 할당
img[:, 35:45] = 205                         # 모든행 35~45 열에 205 할당
img[:, 75:85] = 255                         # 모든행 75~85 열에 255 할당
cv2.imshow('Gray', img)
if cv2.waitKey(0) & 0xFF == 27:
    cv2.destroyAllWindows()
```

위 코드는 120 × 120 크기의 2차원 배열을 dtype은 uint8로 생성했습니다. 2차원 배열이고 가질 수 있는 값은 0~255 사이가 됩니다. OpenCV에서 이미지를 표현하기 위한 NumPy 배열은 반드시 dtype이 uint8이어야 합니다.

0은 검은색을 의미하고 255는 흰색을 의미하므로 그 사이의 값은 값이 커질수록 밝은 색을 나타내고 값이 작아질수록 어두운 색을 표현하는 1채널 그레이 스케일 이미지를 표현할 수 있습니다. 완전히 검은 바탕에 행 단위와 열 단위로 점점 밝은 값을 지정해서 체크무늬 이미지를 만들었습니다.

```py
'''NumPy 배열로 체크무늬 BGR 스케일 이미지 생성(np_bgr.py)'''
```

위 코드는 np.zeros((120,120,3), dtype=np.uint8)로 120행, 120 열 크기의 3개의 채널을 갖는 3차원 배열을 생성했습니다. 3개의 채널은 각각 B(Blue, 파랑),G(Green, 초록), R(Red, 빨강) 값을 나타내는 0~255 사이의 값을 나타냅니다. [예제3-1]과 같은 방법으로 3개의 행과 2개의 열 단위로 10픽셀씩 색상을 지정해서 검은바탕에 여러 가지 색상의 체크무늬 이미지를 생성했습니다.




