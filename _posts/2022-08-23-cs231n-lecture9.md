---
layout: post
title: CS231n Lecture9 Review
category: CS231n
tag: CS231n
---

[![Hits](https://hits.sh/museonghwang.github.io.svg?view=today-total&style=for-the-badge&label=Visitors&color=007ec6)](https://hits.sh/museonghwang.github.io/)

<br>

해당 게시물은 [Standford 2017 CS231n](http://cs231n.stanford.edu/2017/syllabus.html) 강의와 2022년 슬라이드를 바탕으로 작성되었습니다.




<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186296200-1addc525-717e-43ee-bb4f-2c680dc9df54.png">
</p>





# Last Time: Components of Convolutional Networks

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186296735-b3eab059-2b07-42d3-9d3e-33944d75c5b6.png">
</p>

* 앞 강의에서 CNN을 구성하기 위한 여러가지 components들을 살펴보았습니다.
* 그렇다면 components들을 어떻게 조합을 해야 성능이 좋을지, 역사적으로 어떻게 구성해왔는지에 대해 알아보겠습니다. 

<br>





# Today: CNN Architectures

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186297003-4bb28292-53d4-456e-ab40-8451e4683357.png">
</p>

* 여러 네트워크 중 ImageNet Classification Task 에서 좋은 성능을 보였던 대표적인 CNN Architectures들 (AlexNet, VGG, GoogLeNet, ResNet)에 대해 살펴보겠습니다.
* 역사적인 관점에서 아주 흥미로운 모델들, 그리고 아주 최신의 모델들도 다룹니다.

<br>
<br>





# LeNet-5(1998)

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186299945-716a2eac-749e-4e06-bc2f-6dc24d50d0e6.png">
</p>

* 앞 강의에서 LeNet을 다룬 적이 있었지만, 조금 더 자세히 살펴보겠습니다.
* LeNet은 Convolution layer가 성공적으로 적용된 최초의 ConvNet 입니다.
* 슬라이드에서 볼 수 있듯, 이미지를 입력으로 받아서 stride = 1 인 5 x 5 필터를 거치고, 몇 개의 Conv Layer와 pooling layer를 거쳐, 끝 단에 FC Layer가 붙습니다.
    1. Conv - ReLU - Pool(downsampling) 전체 N번 반복 합니다.
    2. Cout x H x W를 한 줄로 펴줍니다.
    3. FC - ReLU 전체 N번 반복 합니다., 마지막 output은 c차원 입니다.
* LeNet은 digit recognition task에서 우수한 성능을 보였습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186307689-77861553-e0e7-44c2-b13a-112fd0ff1639.png">
</p>

* LeNet-5의 구조를 살펴보는데, 구조는 동일하나 각 component의 구성이 바뀐버전을 살펴보겠습니다.
    * 원본 구조는 논문에 있습니다.
* 우선 Input 이미지는 grayscale 이므로 채널은 1입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186307745-be27f663-a565-4363-816f-ae20c1f2a702.png">
</p>

* Filter 사이즈는 1 x 5 x 5, filter 20개.
* P를 조정해서 output size가 같도록 만들어줍니다.
* ReLU로 nonlinear를 취해줍니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186307801-8daa2fb4-4eb2-40a5-90ef-7983ee054870.png">
</p>

* K=2, s=2로 주고 크기를 반으로 다운샘플링 시킵니다.
* [Conv, ReLU, Pool] 1회

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186307861-a7be8e3a-845d-4d69-9edc-782808b3e625.png">
</p>

* Filter 사이즈는 20 x 5 x 5, filter 50개.
* P를 조정해서 output size가 같도록 만들어줍니다.
* ReLU로 nonlinear를 취해줍니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186307943-a9039bec-73c4-4b44-ba45-21a232e7721f.png">
</p>

* K=2, s=2로 주고 크기를 반으로 다운샘플링 시킵니다.
* [Conv, ReLU, Pool] 2회

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186307999-b131a990-8593-4f6a-95d9-382087c065e6.png">
</p>

* 50 x 7 x 7 = 2,450를 flatten 시킵니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186308046-9ece9fb7-7198-4f91-86ad-74a5a4dafd1b.png">
</p>

* FC-Layer를 적용해서, Input은 2450, Output은 500이 되도록 만들어주고, ReLU를 취해줍니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186308103-922baffe-6c24-467f-bdf6-417853396d7b.png">
</p>

* FC를 적용하여, Input은 500, Output은 10이 되도록 만들어줍니다.
* $y ∈ {0, 1, ..., 9}$ 라면, $f(x;W): ℝ^{1 x 28 x 28} → ℝ^{10}$ 입니다.
* 정리하면 네트워크를 통과할때 다음과 같이 진행됩니다.
    * pooling or stride를 사용하여 Spatial size가 감소합니다.
    * channel의 수가 증가됩니다.
* 현대의 architectures들은 점차 이러한 구조를 breaking 하고 있습니다. 이후의 architectures들을 살펴봄으로써 발전양상을 살펴보겠습니다.

<br>
<br>





# AlexNet(2012)

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186311928-5c0e63f3-399d-4915-8a6c-5ea53be4ec86.png">
</p>

* ILSVRC를 remind해보면, ImageNet 데이터셋은 클래스 1000개, training set이 130만개, test set이 10만개로 구성되어있는 DataSet입니다.
* 2011년도 까지는 rule-based 방법으로, edge들을 직접 추출한 후, linear classifier를 얹어서 모델을 만들었습니다.
* 하지만 2012년, AlexNet은 Conv layer를 깊게 쌓은 최초의 대규모 CNN 구조로, 2012년 ImageNet Classification task 에서 엄청난 격차를 보여주면서 Convolution Network는 컴퓨터 비전의 전면에 서게 되었습니다.
* AlexNet은 현재까지 약 50,000번 인용되었는데, CNN아키텍쳐 구성 방법에 영향을 많이 미쳤음을 알 수 있습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186314891-487bba02-7394-4774-90ea-a809af4fcf8f.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186316236-9cf3b910-97a7-41c3-8295-50972533ef90.png">
</p>

* 위 슬라이드는 AlexNet의 전체 architectures구조와, 각 Layer components, Details 입니다.
* AlexNet은 CNN을 깊게 쌓은 심층신경망 형태입니다.
* 모델 구조는 다음과 같습니다.
    * 227x227 크기의 입력 이미지
        * 논문의 그림에서는 input size가 224×224×3 으로 표시되어 있는데 오류입니다. 사실 input size 는 227×227×3 입니다.
    * 5개의 Convolutional layer + Max pooling layer
    * 3개의 Fully connected layer
        * 마지막 층은 softmax를 거쳐 최종적으로 1000개의 class로 분류합니다.
    * ReLU Activation function
* AlexNet의 몇가지 큰 특징은 다음과 같습니다.
    * AlexNet이 ReLU nonlinear activation function을 사용한 첫번째 Neural Network입니다.
    * 채널간 Local response normalization이라는 정규화 방법을 사용하였습니다.
        * 현재는 Batch Normalization을 주로 사용합니다.
    * 당시에는 GPU의 메모리가 부족(3GB)해서 모델을 2개의 GPU에 병렬적으로 분리해서 학습을 수행하였습니다.
    * filpping, jittering, cropping, color normalization 등의 다양한 data augmentaion 을 적용했습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186324548-a36fe9b5-00eb-45d0-bd66-3071f2aafea2.png">
</p>

* 강의에서의 질문에 대한 답을 찾겠습니다.
* $227 × 227 × 3$ size의 input 이미지가 네트워크에 들어갔을때 첫 conv layer (CONV1: 96 11x11 filters applied at stride 4) 를 통과한 output size는 어떻게 될까?
    * 하나의 필터에서 나오는 output size는 $(227 − 11) / 44 + 1 = 55$ 임을 알 수 있습니다. 또한 필터의 갯수가 96 개이므로 총 output size는 $55 × 55 × 96$ 입니다.
* 이때, 첫번째 conv layer의 총 parameter 갯수는 어떻게 될까?
    * conv layer의 파라미터수는 filter size x filter depth x filter 개수로, $(11 × 11 × 3 + 1) × 96$ 개의 파라미터를 가집니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186324574-a3277cea-0495-4b04-b573-dd28f4038cbc.png">
</p>

* 첫번째 conv layer를 거쳐 나온 $55 × 55 × 96$ size의 feature map을 Pooling layer (POOL1: 3x3 filters applied at stride 2) 에 넣어서 만들어진 output size는 어떻게 될까?
    * 하나의 filter 에서 $(55 − 3) / 2 + 1 = 27$ size의 output이 생성되고 pooling layer는 input의 channel(depth)은 그대로 유지함으로써 총 output size는 $27 × 27 × 96$ 입니다.
* 이때, Pooling layer의 총 parameter 갯수는 어떻게 될까?
    * pooling layer는 단순히 pooling하는 과정(ex. max pooling) 이므로 학습시킬 파라미터가 없습니다.

<br>
<br>





# params & memory $ flop

앞에서 layer 및 parameter 계산법에 대해 알아보았는데, 조금 더 자세하게 memory와 flop의 관점까지 바라보는 과정을 진행해보겠습니다. 본 과정은 AlexNet의 구조를 따라가되, 일부 Layer의 수가 수정된 구조입니다.

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186331127-03fbf29c-4237-4aa2-85b8-f170312084b1.png">
</p>

* 이제 AlexNet의 layer들이 어떻게 쌓여있는지 살펴보겠습니다.(일부 변형됨.)
* Conv1 Layer의 Input size는 227 x 227 이며, 3개의 Channel을 가집니다.
* $C_{out} = 64, K = 11, S = 4, P = 2$ 입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186331142-6ed2db76-8bdc-437b-b9b2-c38ced22952f.png">
</p>

* Output channels은 filters의 수와 같습니다.
* $C_{out} = 64$ 이므로, output size의 $C$도 64입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186331157-e0e061dc-c054-438d-a25e-2b339c95f5ff.png">
</p>

* 위 수식대로 입력하면 $H$와 $W$ 는 56입니다.
    * (Input width - Kernel size + 2 x Padding) / Stride + 1 = (227 - 11 + 2 x 2) / 4 + 1 = 56
* 즉 Kernel size, stride, pad에 의해 output의 $H$와 $W$가 결정됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186331184-b18e0e89-5643-4d0f-a51e-ed9f5142a5a2.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186332169-6f630459-8814-4831-9e29-341dec98a52b.png">
</p>

* Conv1의 출력을 저장하기 위한, Output이 차지하는 Memory 공간은 다음과 같이 계산할 수 있습니다.
    * output의 원소 개수는 Channel x Height x Width이므로, 64 x 56 x 56 = 200,704개 입니다.
    * 한 원소당 32-bit floating point 크기를 가진다고 할때, 4 byte의 크기를 가집니다.
    * 따라서, Output이 차지하는 Memory 공간을 계산하기 위해서는 다음과 같이 계산합니다.
        * (number of elements) x (bytes per element) / 1024 = 200,704 x 4 / 1024 = 784KB
        * 즉 output을 저장하기 위해서는 784KB가 필요합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186332204-901fedff-265d-47f2-b812-17ea210903ff.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186332222-52035fb7-9dab-4c89-83a0-5f107bebec11.png">
</p>

* Conv1가 가지는 Parameter의 수를 계산하기 위해서는 layer를 다시 살펴보아야 하는데, 다음과 같이 계산할 수 있습니다.(Filter가 학습되는 파라미터)
    * (number of filter x input channel x kernel size x kernel size) + bias 로 계산할 수 있습니다.
    * Weight는 Output Channel 수 x Input Channel 수 x Kernel size x Kernel size이므로, 64 x 3 x 11 x 11입니다.
    * Bias는 Output Channel의 수와 같으므로, 64입니다.
    * 따라서, 총 파라미터 수는 (64 x 3 x 11 x 11) + 64 = 23,296개 입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186332250-d18b7d3c-58ee-4ab0-b9d3-68b375399ea1.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186332264-c45712c4-6a09-4fbe-b179-221752bd9c82.png">
</p>

* Conv1의 계산에 필요한 floating point(부동소수점) 연산의 수는 다음과 같이 계산할 수 있습니다.
    * Neural Network에서는 (multiply 한번 + add 한번)을 한번의 floating point 연산이라고 계산합니다.
        * 예를 들어, 크기가 3인 두 벡터의 내적은 element-wise 곱셈 3번 수행 후 3번의 덧셈을 수행해서 출력하게 되는데, 이때의 floating point 연산은 3번이라고 계산하는 것입니다.
    * 이는 Output의 총 원소 수 x 각 원소를 계산하기 위한 연산의 수이므로, (Output Channel x Output Height x Output Width) x (Input Channel x Kernel size x Kernel size)로 구할 수 있습니다.
    * 따라서, (64 x 56 x 56) x (3 x 11 x 11) = 72,855,552flops 입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186334452-a24fae9a-1936-4af7-93cf-c8b818155b7c.png">
</p>

* Conv1 계산 후에 ReLU nonlinear activation function를 적용합니다.
* 이후 Pool1 layer를 적용합니다.
    * Channel은 그대로 유지하며, 가로 세로는 down sampling 됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186334488-202916ee-ae8e-40fe-9f5d-60d2c9a4d21a.png">
</p>

* Pooling 레이어에서는 $C_{out} = C_{in}$ 이므로, 64입니다.
* Output Width(=Height)는 kernel, stride, input size에 의해 결정됩니다.
    * (Input width - Kernel size) / Stride + 1 = 53 / 2 + 1 = 27.5
    * 위 결과에서, 소숫점 이하의 값을 내림 해주면 27이 됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186334508-e73f5ee4-3444-4471-afd1-23de0b4dcfe9.png">
</p>

* Pool1의 출력을 저장하기 위한, Output이 차지하는 Memory 공간은 다음과 같이 계산할 수 있습니다.
    * output의 원소 개수는 Channel x Height x Width이므로, 64 x 27 x 27 = 46,656개 입니다.
    * 한 원소당 32-bit floating point 크기를 가진다고 할때, 4 byte의 크기를 가집니다.
    * 따라서, Output이 차지하는 Memory 공간을 계산하기 위해서는 다음과 같이 계산합니다.
        * (number of elements) x (bytes per element) / 1024 = 46,656 x 4 / 1024 = 182.25KB
        * 즉 output을 저장하기 위해서는 182.25KB가 필요합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186334533-77388587-c630-423a-9376-69d7386857e7.png">
</p>

* Pool1는 learnable parameter가 없습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186334551-9841f4cf-076c-4b3f-8e28-866c90bd7710.png">
</p>

* Pool1의 계산에 필요한 floating point(부동소수점) 연산의 수는 다음과 같이 계산할 수 있습니다.
    * Pooling Layer에서는 출력 후 채널별로 더해주는 연산이 없기 때문에, 식은 (Output Channel x Output Height x Output Width) x (Kernel size x Kernel size)가 됩니다.
    * 따라서, (Output Channel x Output Height x Output Width) x (Kernel size x Kernel size) = (64 x 27 x 27) x (3 x 3) = 419,904 flops입니다.
        * Convolutional layer에 비해 현저히 적습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186340360-438f3e20-45a4-4cd5-bd8e-f5fdce93077f.png">
</p>

* Conv Layer와 pooling Layer들을 여러번 통과 후에, Fully-Connected Layer와의 연결을 위해 Flatten시킵니다.
    * 즉, 입력을 모두 1차원 벡터로 펼쳐주는 연산을 수행하게 됩니다.
    * 이러한 연산을 수행하는 layer를 Flatten layer이라고 하며, 단순히 펼치는 작업 뿐이므로 학습되는 파라미터와 flop은 없습니다.
* 따라서, 출력은 Input Channel x Height x Width = 256 x 6 x 6 = 9216이 됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186340375-92215544-f99d-499d-9897-c966b4ce7cb3.png">
</p>

* Flatten layer를 통과한 1차원 벡터는 Fully Connected layer에 입력으로 들어가게 됩니다.
* FC6에 대한 파라미터 개수는 weight matrix의 크기와 같습니다.
    * 따라서 input의 채널수 x output의 채널 수 + bias term 입니다.
    * FC6에 대한 부동소수점 연산의 수는, 내적을 각 행마다 연산을 하는데(9216번), $W$ 의 행 개수가 4096이므로, 9216 x 4096 = 37,748,736 이 됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186340390-b8d2ad97-2ed4-4fd7-bcc9-6368f3f21def.png">
</p>

* 그리고 마지막 Fully connected layer는 1000개의 category에 대한 score를 출력하게 됩니다.
* 마지막 FC 레이어의 output은 ImageNet 데이터셋의 class가 1000개이기 때문에 1000개로 맞춰줍니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186340412-a6a54520-ee80-412a-9b14-359dc4361007.png">
</p>

* AlexNet의 모델 구성(위 슬라이드의 빨간색 박스)은 단지 Trial and error를 통해 가장 성능이 좋았을 때의 모델 구성일 뿐입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186340428-41176545-7adc-4eb9-b701-c7cfef8f0cf3.png">
</p>

* 초록색 박스 부분을 보면, 네트워크를 통과하며 메모리, 파라미터, flop이 감소하게 되는 것을 볼 수 있는데, 이는 AlexNet뿐만 아니라, 여러 CNN에서도 따르고 있는 trend입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186398920-7baa5a67-ac2c-44d2-a35b-228b4447ab29.png">
</p>

* AlexNet에서의 메모리, 파라미터, flops에 대한 설명을 정리하면 다음과 같습니다.
    * Memory는 Conv layer가 더 많은 부분을 차지합니다.
        * 초기 Input은 픽셀 수가 높기(이미지 해상도가 높기) 때문입니다.
    * Parameter의 수는 FC layer가 더 많습니다.
        * 학습할 양이 많기 때문입니다.
    * Flops(부동소수점 연산량)은 대부분 Conv layer가 더 많은 연산을 수행한다.
        * 즉 Conv레이어를 쌓을 때 연산 부담이 커집니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186401452-f85c3703-37bc-4178-9302-7baab7a27468.png">
</p>

* 추가적으로 AlexNet은 대체로 다른 Conv Net의 다이어그램과 유사하긴 하지만, 분산처리(모델이 두개로 나눠진 구조)를 했다는 차이점이 있습니다.
    * AlexNet을 학습할 당시에 GTX580으로 학습시켰는데, 메모리가 3GB 밖에 없어서 전체 레이어를 GPU에 다 넣을 수 없었기 때문에 네트워크를 GPU에 분산시켜서 학습하였습니다.
    * 따라서 모델을 2개로 나누어 두 개의 GPU가 각각 절반의 뉴런, feature map를 가지는 구조로 학습이 되었습니다.
* 따라서 위의 그림을 보면 첫번째 conv layer 를 나온 output size가 $55 × 55 × 96$ 이 아닌 $55 × 55 × 48$ 이 되어있는 모습을 확인할 수 있습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186401479-7d666e0a-5576-43fe-a963-355c505beeb4.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186401525-99be61fe-73a8-49ea-bbbd-3dc457f93239.png">
</p>

* 따라서 위 그림과 같이 CONV1, CONV2, CONV4, CONV5에서는 오직 절반의 feature map으로만 연산을 합니다.
* CONV3, FC6, FC7, FC8에서는 나뉜 feature map들이 합쳐져 연산이 되어 최종적으로 전체 네트워크가 전체 feature map을 사용할 수 있게 됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186402968-db13ba51-3832-4254-9fa6-2687393515fc.png">
</p>

* 정리하면, AlexNet은 ImageNet Classification Benchmark의 2012년도에 최초의 CNN기반 우승 모델입니다.
* 또한 AlexNet은 다양한 Task의 transfer learning에 많이 사용되었습니다.

<br>
<br>





# ZFNet(2013)

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186399619-8defa3d3-fddb-4335-a215-364bca1c7703.png">
</p>

* ZFNet은 AlexNet 이후, ILSVRC 2013년에 우승한 아키텍쳐입니다.
* AlexNet에서 많은 하이퍼파라미터에대해 시행착오를 거쳐, layer configuration을 수정하여 우승하였습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186400253-fbeb3158-0002-4c43-9b61-47b5d940fde4.png">
</p>

* ZFNet은 AlexNet과 아이디어는 동일하지만, 더 큰 버전의 AlexNet입니다.
    * AlexNet과의 차이점은 1번째 Conv layer에서 Filter size와 Stride를 줄여서 더 세밀하게 탐색하도록 하였고, 이후의 Conv layer에서도 출력 필터의 수를 더 늘렸습니다.
    * Conv1에서 커널사이즈와 stride사이즈를 축소하여, 다음 layer가 더 고해상도로 인식하게 됩니다.
    * Conv3, 4, 5에서 필터 개수를 증가시킴으로써 연산 횟수, learnable parameter의 개수가 증가했습니다.
* 따라서, 단지 네트워크를 더 크게 하고 연산량을 늘려서 성능을 높인 More trial and less error라고 볼 수 있습니다.

<br>
<br>





# VGGNet(2014)

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186403711-c032bcf3-557e-4461-ad29-7317f5142f6e.png">
</p>

* 2014년도에 넘어오면서 CNN 구조는 VGG, GoogleNet과 같이 더 복잡하고 깊게 만들어졌습니다.
    * 2012/2013년에는 8개의 레이어인 반면, 2014년에는 19레이어와 22 레이어로 늘어났습니다.
* ILSVRC 2014의 우승자는 Google의 GoogLenet이며, Oxford의 VGGNet이 2등을 차지했습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186406475-a8d8318f-2087-4465-9dc6-27a45f0e7429.png">
</p>

* VGGNet은 아주 심플하면서도 nice한 아키텍쳐이며, ImageNet에서 7.3%의 Top 5 Error를 기록했습니다.
    * VGG는 AlexNet보다 더 작은 필터를 이용하고, 더 많은 레이어를 가지는 구조로 이루어져있습니다.
    * 또한 AlexNet에서는 8개의 레이어였지만 VGGNet은 16에서 19개의 레이어를 가집니다.
    * 그리고 VGG는 이웃픽셀을 포함할 수 있는 가장 작은 필터인 3×3 size의 filter를 사용하며, stride 1, padding 1 만을 사용한 CONV layer 들을 구성하였습니다.
* 즉 VGG는 네트워크에 설계에 대한 어떠한 원칙을 갖도록 해준 모델입니다.
    * AlexNet과 ZFNet은 단순히 trial and error였으며, VGGNet을 통해 네트워크의 확장과 축소를 더욱 쉽게 생각할 수 있게 되었습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186408695-3d82674a-205d-4f29-9506-ce6677cc789a.png">
</p>

* 강조하면 VGGNet이 중요한 이유는 CNN아키텍쳐의 디자인 가이드를 제시했기 때문입니다.
* VGG는 아주 심플하고 깔끔한 디자인 규칙을 따릅니다.
    * NN은 기본적으로 5개의 stage로 이루어져 있으며, Stage 1, 2, 3에서는 conv두번에 pooling, 그리고 Stage 4,5에서는 conv를 4-5번하고 pooling 레이어를 쌓았습니다.
    * 모든 Conv layer는 3x3 크기이고, stride와 padding은 1입니다.
    * 모든 Max pool은 2x2 크기이고, stride는 2이며, Max pool 이후에는 channel을 2배로 늘립니다.

<br>





# Design Rules of VGG

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186408790-52ea7b57-6994-4882-a2d3-7a88e8441eb8.png">
</p>

* 지금부터 이러한 구성으로 신경망을 구성한 motivation을 알아보겠습니다.
* 모든 Conv Layer가 3x3 size 및 pad가 1인 디자인 규칙에대해서 살펴보겠습니다.
* 위 슬라이드의 Option 1과 Option 2는 큰 Kernel size를 가진 Conv layer와 작은 kernel size를 가진 Conv layer를 여러겹 쌓은 경우를 비교한 것인데, 그 결과는 다음과 같습니다.
    * 두 경우 모두에서 네트워크가 바라보는 입력의 양(receptive field)이 동일합니다.
        * 5x5 Conv layer에서 영향을 받는 receptive field는 3x3 크기의 Conv layer 2개를 쌓았을 때와 동일합니다.
        * 마찬가지로, 7x7 크기의 Conv layer는 3x3 크기의 Conv layer 3개를 쌓았을 때와 영향을 받는 receptive field가 동일합니다.
        <img alt="image" src="https://user-images.githubusercontent.com/77891754/186418212-40b46ec6-e8e1-4c84-9cf1-6af7b7021df7.png">
        <img alt="image" src="https://user-images.githubusercontent.com/77891754/186418225-e3afa76c-9478-4f9c-ad0b-a255e8a3aa84.png">
        <img alt="image" src="https://user-images.githubusercontent.com/77891754/186418252-9dfc49b7-edf5-47aa-a93b-64187fa959ea.png">
        <img alt="image" src="https://user-images.githubusercontent.com/77891754/186418271-a52455b5-7cce-4c7c-b6c1-09082ecc7bf1.png">
        <img alt="image" src="https://user-images.githubusercontent.com/77891754/186418297-ed37eaa0-bef5-40ff-8ae7-6bd7bdadc079.png">
    * 그러므로 작은 kernel size의 Conv layer를 여러겹 쌓은 경우에서 파라미터와 연산량이 더 적으며, 학습 속도를 개선할 수 있습니다.
        * Option 1
            * param = $Input Channel 수 x Output Channel 수 x Kernel size x Kernel size = C_{in} x C_{out} x 5 x 5 = 25C^2$
            * FLOPs = $(Output Channel x Output Height x Output Width) x (Input Channel x Kernel size x Kernel size) = (C_{out} x H x W) x (C_{in} x 5 x 5) = 25C^2HW$
        * Option 2
            * param = $9C^2 + 9C^2 = 18C^2$
            * FLOPs = $9C^2HW + 9C^2HW = 18C^2HW$
        * 즉 Params와 FLOPs 계산결과를 보면 3x3 Conv layer를 2개 쌓은 것이 5x5 Conv layer보다 더욱 적습니다.
        * 만약 $3×3$ size 필터를 가진 conv layer 세 개와, $7×7$ size 의 필터를 사용한 conv layer 한 개를 비교하면 다음과 같이 됩니다.
            * $3 * (3^2C^2) = 27C^2$ vs $7^2C^2 = 49C^2$
    * 또한 작은 kernel size의 Conv layer를 여러겹 쌓은 경우가 더 높은 표현력을 갖게 됩니다.
        * Conv layer를 여러번 쌓게되면, 더 많은 ReLU를 통과하며 비선형성(non-linearity)이 추가되므로 더 높은 표현력을 가지게 됩니다.
* 따라서, 본 디자인 규칙은 작은걸 여러개 쌓는게 더 좋으니까 하이퍼파라미터로서 kernel size는 고려하지 않아도되고, 네트워크의 깊이만 고려하면 된다는 의미를 담고 있습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186540038-d0e0a8ed-bbb8-4276-a9a8-eab6026e63a5.png">
</p>

* 다음 디자인 규칙은, 모든 Max pool은 2x2 크기이고, stride는 2이며, Max pool 이후에는 channel을 2배로 늘리는 것에대해 살펴보겠습니다.
* 위 슬라이드의 Option 1과 Option 2는 Max pool 이후 channel을 2배 늘린 경우의 전과 후를 비교한 것인데, 그 결과는 다음과 같습니다.
    * Memory : 절반으로 줄어들었습니다.
    * Parameters : 4배 증가했습니다.
    * FLOPs : 그대로 유지됩니다.
* 여기서, 중요한 것은 연산량(FLOPs)가 유지된다는 점입니다.
    * 결국 channel을 2배 늘린 이유는 픽셀이 반으로 줄어도, 각각의 conv stage에서는 부동소수점 연산 수를 갖게 주기 위함입니다.
* 따라서, 디자인 규칙 2는 각 stage에서의 Conv layer의 kernel size(each spatial resolution)가 변해도 Max pool 이후 channel을 2배로 해줌으로써 연산량을 동일하게 유지할 수 있다는 의미를 담고 있습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186543940-2a47df2a-4b00-46cc-9340-19326febaa3d.png">
</p>

* 다음은 VGGNet의 전체 네트워크를 한번 살펴보겠습니다.
* AlexNet의 총 파라미터 수는 60M인 반면, VGG는 총 파라미터 수는 약 138M 정도임을 알 수 있습니다.
* VGG는 메모리 사용량이 많은 모델입니다.
    * 초기 레이어에서 많은 메모리를 사용하는 것을 알 수 있습니다.
    * Sparial dimention이 큰 곳들이 메모리를 더 많이 사용합니다.
* 마지막 레이어는 많은 파라미터를 사용합니다.
    * FC-Layer는 dense connection이기 때문에 엄청난 양의 파라미터를 사용합니다.
    * 최근의 네트워크들은 너무 많은 파라미터를 줄이기 위해 FC Layer를 없애버리기도 합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186545124-d55a3ef9-bc5e-401a-8310-1ca675fd15d3.png">
</p>

* 다음은 VGGNet의 Details 입니다.
    * VGGNet은 ImageNet 2014 Classification Challenge에서 2등, Localization에서는 우승을 했습니다.
    * AlexNet에서 사용한 Local response normalization은 사용하지 않습니다.
    * VGG16과 VGG19은 아주 유사하며, VGG19가 아주 조금 더 좋습니다. 보통 16을 더 많이 사용합니다.
    * 그리고 모델 성능을 위해서 앙상블 기법을 사용했습니다.
    * VGG의 마지막 FC-Layer인 FC7은 4096 사이즈의 레이어인데 아주 좋은, feature represetation을 가지고 있는 것으로 알려져있습니다.
        * 아주 좋은 feature representation으로, 다른 데이터에서도 특징(feature) 추출이 잘되며, 다른 Task에서도 일반화 능력이 뛰어난 것으로 알려져있습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186545449-1f8e2f4f-b04e-4240-8131-427d7b492da2.png">
</p>

* 마지막으로 위 슬라이드는 VGGNet과 동일하게 5개의 Conv layer와 3개의 FC layer를 가지는 AlexNet을 비교한 것입니다.
* 이를 통해 VGGNet이 AlexNet에 비해 엄청나게 큰 모델이라는 것을 알 수 있습니다.

<br>
<br>





# GoogLeNet

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186545596-d3ebb744-3ac5-46c0-bd38-f42e39799566.png">
</p>

* GoogLeNet은 ILSVRC 2014 Classification Challenge에서 우승한 모델입니다.
* VGGNet과 마찬가지로 depth가 깊어졌으며, 더 좋은 accuracy를 달성했습니다.
* GoogLeNet은 계산 효율성을 고려하여 구성한 아키텍쳐입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186546944-5275113f-ab29-431f-889a-82452658d59b.png">
</p>

* 즉 GoogLeNet은 성능을 높임과 동시에 네트워크 계산 효율성을 고려하는 것에 집중한 모델입니다.
    * AlexNet에서 VGG까지의 모델들은 모두 네트워크의 크기가 커질수록 좋은 성능을 보이는 것에 집중한 모델이었지만, GoogLeNet은 효율적인 CNN을 설계하는 방법에 집중하였습니다.
    * 즉 GoogLeNet은 Parameter 개수, memory 사용, 연산 수를 줄이는 것에 중점을 두었습니다.
    * Mobile에서는 training단계를 거치지는 않지만, Testing time에서 forward pass를 거쳐야 하므로 효율성이 중요합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186547361-0b78ae98-b5da-40bb-b33f-41aaecf4ff49.png">
</p>

* GoogLeNet도 엄청 깊은 네트워크입니다.
* 반복하지만 GoogLeNet에서 가장 중요한 것은 효율적인 계산에 관한 특별한 관점이 있다는 것과 높은 계산량을
아주 효율적으로 수행하도록 네트워크를 디자인했다는 점입니다.
* GoogLeNet은 Inception module을 사용합니다.
* GoogLeNet에는 파라미터를 줄이기 위해서 FC-Layer가 없습니다.
* 또한 전체 파라미터 수가 5M 정도입니다.
    * 60M인 AlexNet보다 적지만, 그럼에도 불구하고 훨씬 더 깊습니다.
* ILSVRC 2014에서 6.7%의 top-5 error로 우승했습니다.

<br>





# GoogLeNet: Aggressive Stem

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186547988-78323a76-86b1-4491-8711-26b0e5ff3ad0.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186547902-81d39a86-818d-4a0d-aef6-77c6ee352e29.png">
</p>

* 지금부터 GoogLeNet의 구조를 톺아보겠습니다.
* GoogLeNet의 첫번째 아이디어는 맨 처음에 Stem Network를 사용한 것입니다.
    * 앞선 아키텍쳐들은 앞쪽 단계에서 고해상도의 이미지에 Conv layer 적용시 부동소수점 연산이 집중되어 있었습니다. 
    * GoogLeNet은 해당 연산 수를 줄이기 위해서, 앞쪽 단계에서 빠르게 downsampling을 진행하는 선택을 했습니다. 
    * 즉 Stem Network는 입력 이미지를 아주 aggressively하게 다운샘플링 하는 역할을 수행하는 네트워크를 의미하는데, 이를 사용한 이유는 초기의 expensive한 Conv 연산을 피하기 위함입니다.
* 슬라이드의 표에서, 3번의 Conv layer만으로 224x224 크기의 입력(resolution)이 28x28로 빠르게 줄어든 것을 볼 수 있습니다.
    * 앞쪽 단계에서 빠르게 downsampling을 진행함으로써, VGGNet에 비해 memory, parameter 수, 연산 수 모두 줄어들었음을 알 수 있습니다.

<br>





# GoogLeNet: Inception module

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186548471-7a8eb2b5-000e-4258-a1cf-e3ee8894c01f.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186548739-03629995-9c16-4897-9642-5f2366fca7cf.png">
</p>

* GoogLeNet의 두번째 아이디어는 연산 효율성을 올릴 수 있었던 핵심적인 부분인 Inception module입니다.
* inception module은 좋은 local network typology를 디자인 하기위해 설계되었으며, 네트워크 안의 네트워크 (network within a network)의 개념으로 만들어졌습니다.
* GooleNet은 Inception module들을 쌓아올려 구성합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186549150-13259c7a-6285-4bf0-ae4a-5d8a07c1430a.png">
</p>

* 즉 네트워크 안의 Local Network를 Inception module 이라고 합니다.
* 슬라이드의 Inception module은  Naive Inception module입니다.
* Inception Module 내부에는 동일한 입력을 받는 서로 다른 다양한 필터들이 "병렬로" 존재합니다.
    * 1×1 CONV, 3×3 CONV, 5×5 CONV, 3×3 MAX POOL 연산이 병렬적으로 이루어집니다.
* 각 filter를 통해 연산되어 나온 output 들을 모두 depth 방향으로 합칩니다.(concatenate)
    * 합쳐진 하나의 출력을 다음 레이어로 전달합니다.
* 하지만 Naive Inception module은 계산 비용의 문제점이 존재합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186550229-198ed945-4e28-4d66-9a8c-336a206a3a11.png">
</p>

* 예제를 살펴보겠습니다.
* 1×1 CONV 128개, 3×3 CONV 192개, 5×5 CONV 96개, 3×3 MAX POOL이 있으며, 각 연산은 병렬적으로 이루어지며, stride를 조절하여 입/출력 간의 spatial dimention을 유지시켜줍니다.
* Module input이 28×28×256일때 다음과 같습니다.
    * 1 x 1 x 128 conv의 출력: 28 x 28 x 128
    * 3 x 3 x 192 conv의 출력: 28 x 28 x 192
    * 5 x 5 x 96 conv의 출력: 28 x 28 x 96
    * 3 x 3 Pool의 출력: 28 x 28 x 256

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186552650-3fe6bfa2-9d15-4c61-82fb-d715797136a5.png">
</p>

* 모든 출력 값들을 depth-wise로 합친(concat) 사이즈를 계산해볼때 28 x 28 은 동일하고 depth가 점점 쌓이게 됩니다.
    * Inception module의 입력: 28 x 28 x 256
    * Inception module의 출력: 28 x 28 x (128 + 192 + 96 + 256) = 28 x 28 x 672 = 529K
    * spatial dimention은 변하지 않았지만 depth가 엄청나게 증가했습니다.
* 그리고 각 레이어들의 계산량을 한번 살펴보면 다음과 같습니다.
    * 1 x 1 x 128 conv의 연산량: 28 x 28 x 128 x 1 x 1 x 256
        * 1 x 1 conv는 각 픽셀마다 1 x 1 x 256 개의 내적연산을 수행되므로, 픽셀 당 256번의 곱셈 연산이 수행됩니다.
        * 그리고 각 픽셀이 총 28 x 28이며, 128개의 filter를 만들기 때문에 다음과 같이 연산됩니다.
    * 3 x 3 x 192 conv의 출력: 28 x 28 x 192 x 3 x 3 x 256
    * 5 x 5 x 96 conv의 출력: 28 x 28 x 96 x 5 x 5 x 256
    * 따라서 하나의 Inception Module에서의 전체 연산량은 854M가 되며, 이는 연산량이 아주 많습니다.
* Pooling layer 또한 입력의 Depth를 그대로 유지하기 때문에 문제를 악화시킵니다.
    * 레이어를 거칠때마다 Depth가 점점 늘어만 갑니다.

<br>

## Reminder: 1x1 convolutions

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186555241-13beaf92-a12f-499a-b1b0-6f6c7d844e61.png">
</p>

* Naive Inception module은 계산 비용의 문제점을 해결하기 전에 1x1 conv를 다시 한번 살펴보겠습니다.
* 1x1 conv는 각 spatial location에서만 내적을 수행합니다.
    * 즉 spatial dimensions을 보존하면서, depth만 줄일 수 있기에, 입력의 depth를 더 낮은 차원으로 projection할 수 있습니다.
* Input feature map들 간의 선형결합(linear combination) 또는 각 input pixel에 동일한 FC layer를 적용하는 것으로 해석할 수 있습니다.

<br>





# Solution: "bottleneck layers"

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186556075-be196a78-03af-4aea-bb3a-6234959abf71.png">
</p>

* Naive Inception module은 계산 비용의 문제점을 해결하기위한 key insight는 "bottleneck layer"를 이용하는 것입니다.
* "bottleneck layer"는 feature의 depth를 감소시키기 위해 1x1 convolutions을 사용하는 것을 의미합니다.
* "bottleneck layer" 아이디어는 입력의 depth를 줄이는 것입니다.
    * ouput의 채널수가 계속해서 많아져 연산량이 증가하는 문제를 해결하기 위해 Inception module 내부의 각 연산 과정에도 이러한 1x1 convolutions을 추가해 input의 차원(depth)을 축소합니다.
    * 3×3 conv, 5×5 conv 연산 이전에 1×1 conv 연산으로 함으로써 3×3 conv, 5×5 conv 연산에 들어갈 input 의 channel 수를 줄입니다.
    * pooling layer 에서는 3×3 pooling 연산 이후에 1×1 conv 연산을 적용하여 output 의 channel 수를 줄입니다.
* 즉 1x1 convolutions이 bottleneck layers의 역할로 추가되는 것입니다.
    * 픽셀별로 nonlinearity를 줄 수 있는 방법으로서, 픽셀별로 fc layer에 한번 돌린 것보다 효과가 좋습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186556786-48e4981c-0b1c-4f20-8129-808f45987542.png">
</p>

* 즉 GoogLeNet은 Inception module with dimension reduction을 사용하였습니다.
* Inception 모듈은 VGG와 같이 kernel size를 하이퍼파라미터에서 고려하지 않도록 설계되었습니다.
    Inception 모듈은 4개의 parallel한 branch가 있는데 각각 1x1 Conv, 3x3 Conv, 5x5 Conv, Max pool입니다.
    * 즉, Inception 모듈 안에서 다양한 크기의 kernel size를 고려하게 되므로, 하이퍼파라미터로 고려할 필요가 없게 되는 것입니다.
* 또한 Inception 모듈에서 또 한가지 주목할 것은 1x1 Conv 연산입니다.
    * 연산 비용이 비싼 spatial한 Conv 연산을 수행하기 전에 1x1 Conv 연산을 통해 input channel의 차원을 조절하여(줄여서) 연산량을 줄이는 방법을 사용하였습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186557614-f0a7668c-04f4-42d4-b3ae-5c9a611ec973.png">
</p>

* 결과적으로 1x1 convolutions를 추가함으로써 연산량을 많이 줄일 수 있습니다.
* 그리고 이를 통해 배울 수 있는 점은 1x1 convolutions를 이용하면 계산량을 조절할 수 있다는 사실입니다.
* 이때, 1x1 convolutions을 사용함으로써 input의 정보 손실이 일어나지 않을까라고 생각할 수도 있는데, 1x1 convolutions을 추가함으로써 네트워크가 더 깊어지는 효과도 있고 각 conv 연산 이후 ReLu와 같은 non-linear activation function을 사용함으로써 모델에 비선형성(non-linearity)를 부여할 수 있어 도움이 됩니다.

<br>





# GoogLeNet: Global Average Pooling

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186560353-ad00b984-0038-47c4-9558-39e4457ed7de.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186559689-9f0a135b-dfd9-4a30-b8ca-bfbb0c76ba78.png">
</p>

* GoogLeNet의 세번째 아이디어는 네트워크의 맨 마지막에서 수행한 Global Average Pooling입니다.
    * AlexNet에서 VGGNet까지의 네트워크에서 보았듯이, 모델 파라미터의 대부분은 마지막의 FC layer에서 나오게 됩니다.
    * GoogLeNet에서는 마지막 Conv layer의 출력을 1차원 벡터로 만드는 Flatten 연산 대신, 파라미터를 줄이기 위해 Global Average Pooling을 사용하여 이러한 파라미터의 수를 줄이며 efficiency를 높였습니다.
* Global Average Pooling은 마지막 Conv layer의 출력에서, 각 채널별로 1개씩의 평균을 구해 출력하는 방법입니다.
    * 슬라이드의 윗쪽 표를 보면, 7x7 크기의 1024개의 채널이 Global Average Pooling에 입력으로 들어가서, 1024 크기의 1차원 벡터가 출력되는 것을 확인할 수 있습니다.
* 슬라이드 아래의 표(VGGNet)와 비교해보면, Global Average Pooling이 VGGNet에 비해 엄청난 양의 파라미터 수를 줄여주었다는 것을 알 수 있습니다.

<br>





# GoogLeNet: Auxiliary Classifiers

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186560418-ca105006-ba9b-4dc5-8a9a-65cb4024631c.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186560623-b28e788e-7ddb-4f23-8ec2-82b355390abc.png">
</p>

* GoogLeNet의 마지막 아이디어는 Auxiliary Classifier입니다.
    * Batch Normalization이 나오기 이전에는 deep Network 트레이닝이 어려워서, 10개 이상의 layer를 가지는 네트워크를 학습시키기 위한 여러가지 방법들(hack)을 사용하였는데, 그중 GoogLeNet에서 사용한 방법이 Auxiliary Classifier입니다.
    * Auxiliary classifier는 AvgPool - 1×1 Conv - FC - FC - Softmax로 이루어져 있습니다.
* 슬라이드에서 2개의 빨간색 박스가 Auxiliary Classifier인데, 이는 네트워크의 최종 출력과 같이 class score를 출력합니다.
    * 따라서, GoogLeNet은 총 3개의 다른 class score를 출력하였습니다.
        * 하나는 네트워크의 마지막, 나머지 두개는 네트워크의 중간
* 그리고 이 중간의 두 classifier의 score에 대해서도 trainset loss를 계산하여 gradient가 전파되도록 하였습니다.
    * 이는 네트워크에서 gradient가 더 잘 전파되도록 하는 효과가 있었습니다.
    * 네트워크의 끝에만 gradient를 주입하는 것보다 네트워크의 중간에 gradient를 두번 더 주입하는 것이라고 생각하면 됩니다.
* 즉 이러한 Auxiliary classifier 를 사용해서 네트워크 중간 중간에서 class를 분류하고 loss값을 이용함으로써 네트워크가 깊어져도 네트워크의 중간 중간에서 gradient 를 잘 이용하여 학습할 수 있게 합니다.
* inference하는 과정에서는 중간에 2개의 auxiliary classifier를 모두 제거 후, 제일 마지막 layer의 softmax만을 사용합니다.

<br>





# GoogLeNet Architecture

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186561762-eba17519-bdb1-4d9d-8cf3-880b1ddb45bb.png">
</p>

* 전체 아키텍쳐의 모습입니다.
* 정리하면 GoogLeNet에는 가중치를 가진 레이어가 총 22개이며, 각 Inception Module은 1x1/3x3/5x5 conv layer를 병렬적으로 가지고 있습니다.
* AlexNet보다 12배 작은 파라미터를 가지고있고, ILSVRC 2014 clssification의 우승 모델입니다.
* GoogLeNet은 아주 신중하게 디자인된 모델이며, Google의 거대한 클러스터를 이용한 cross validation을 수행한 결과 나온 최적의 디자인 입니다.

<br>
<br>





# ResNet(2015)

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186562478-092c0974-76a4-4de9-9c74-1d9ab27bb8d8.png">
</p>

* ResNet은 ILSVRC 2015 Classification Challenge에서 우승한 모델입니다.
* ResNet은 layer개수를 크게 증가시키면서, accuracy는 반으로 줄이는 혁신을 선보였습니다.
    * ResNet 아키텍쳐는 152 레이어로 엄청나게 더 깊어졌습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186563306-666b6b8c-56bd-49e5-b15c-a1ad3fdee4fe.png">
</p>

* ResNet 아키텍쳐는 이전의 다른 모델들에 비해 엄청나게 깊은 네트워크입니다.
* ImageNet데이터를 분류하기 위해 ResNet은 152개의 레이어를 가지고 있습니다.

<br>





# motivation of ResNet

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186565888-4c4f2708-10e9-41cb-825f-e6ed1532daf2.png">
</p>

* Batch normalization이 등장하고 사람들은 10개 이상의 layers를 쌓는 deeper network가 가능해짐을 깨달았습니다.
* 기존 트렌드는 더 깊은 네트워크일수록 더 좋은 성능을 내 왔기 때문에 deeper network에서 더 좋은 성능을 낼 것으로 기대했지만, 문제는 너무 깊어지니 BN을 적용했음에도 불구하고 성능이 더 나빠졌습니다.
    * 위 그림에서, 56개 layer 모델이 20개 layer 모델보다 성능이 좋지 않은 것을 확인할 수 있습니다.
* 처음에는 이러한 현상이 딥러닝 모델이 Overfitting되었기 때문일 것이라고 추측하였습니다.
    * 따라서 더 깊은 모델은 학습 시 Overfitting이 된 것이라고 가정을 하고 실험을 진행했습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186565914-e55aa282-2b92-45b3-8198-a01cb224f42c.png">
</p>

* 하지만 실험을 통해 알게된 사실은 매우 깊은 네트워크가 Overfitting이 아니라 오히려 Underfitting되었다는 것입니다.
    * 위 슬라이드의 왼쪽과 오른쪽 그래프는 각각 Training data, Test data에 대한 결과인데, deeper model에서 둘 모두 안좋은 성능을 보이기 때문에 overfitting 문제가 아닙니다.
        * 그리고 overfit이 발생한다면 test error는 높더라도 training error는 아주 낮아야 정상일 것입니다.
        * 그런데 56-layer의 traing error을 보면 20-layer보다 안좋습니다.
        * 그러므로 더 깊은 모델임에도 test 성능이 낮은 이유가 over-fitting 때문이 아니라는 것을 알 수 있습니다.
    * Training error을 살펴본 결과 deep model은 사실상 underfitting 되어있었습니다.
        * Training자체가 잘 되지않았습니다.
* 이러한 현상이 발생하는 이유는 네트워크가 깊어짐에 따라 모델을 최적화(optimize)하여 학습시키기 어렵다는 점 때문입니다.
    * 네트워크가 깊어지면 vanishing gradient/exploding gradient 문제 등이 발생하여 모델을 학습이 시키기 어려워져 오히려 안좋은 성능을 보이는 것입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186568356-1daff28a-9c21-4cda-9354-7ac3b103ec83.png">
</p>

* deeper models은 shallower models보다 더 많은 representation power(more parameters)를 가집니다.
* 그렇다면 deeper models은 shallower models을 재현할 수 있어야 한다는 것입니다. 적어도 비슷한 성능을 내기를 원한 것 입니다.
    * shallower models의 layer를 deeper models의 layer에 복사한 후, 나머지 layer를 identity function으로 생각한다면 얕은 모델을 emulate 한다고 생각할 수 있습니다.
        * ex. 첫 20개의 레이어는 20개의 레이어를 가진 모델을 통째로 복사하고 나머지 레이어는 identity function 역할만 하면되기에 이론적으로 56개의 레이어의 모델은 최소한 20개 레이어의 모델만큼의 성능은 보장됩니다.
    * 따라서 deeper models은 최소한 shallower models만큼 효과적이어야 합니다.
* 하지만, 여러 실험에서 깊은 모델이 underfitting 되었다는 것이 의미하는 것은, 깊은 모델이 얕은 모델을 재현(emulate)하는 identity function를 optimization하는데 문제가 있다는 것을 의미합니다.

<br>

* 결론적으로, 다음과 같은 가설을 세웁니다.
    * 해당 문제는 training 문제가 아니라, optimization problem 입니다.
    * deeper models은 optimization하기 더 어려우며, 때문에 특히 shallower models을 모방하기 위한 identity functions을 학습하지 않습니다.
* deeper models이 적어도 shallower models만큼 우수하려면, 네트워크를 수정해서 identity function을 잘 학습하도록 하는 것이 해결방안입니다.
    1. 더 얕은 모델의 가중치를 깊은 모델의 일부 레이어에 복사합니다.
    2. 그리고 나머지 레이어는 input을 output으로 그냥 내보내서 identity mapping을 합니다.
* 이렇게 구성하면 Deeper Model의 학습이 제대로 안되더라도 적어도 Shallow Model 만큼의 성능은 보장됩니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186581024-c773d18e-a26e-4a96-bab1-250f2587a214.png">
</p>

* 이러한 문제를 해결하기 위해 ResNet에서는 identity function을 더 잘 학습하기위해서, skip connection을 이용한 Residual block을 사용합니다.
* 즉, 수정된 네트워크 구조는 Residual Block입니다.
    * Residual block은 일반적인 여러개의 conv layer들로 이루어져있고, 여기에 skip connection을 추가한 구조로 이루어져있습니다.
    * Skip connection이란, 이전 레이어의 input(residual block 의 처음 input)을 그대로 residual block의 output에 mapping하여 최종 output을 만들어내는 것입니다.
    * 여기서 이전 레이어에 가져와 그대로 합쳐주는 x를 identity라고 하고, 이것을 이후 output에 합치는 것을 identity mapping 이라고 표현합니다.
        * 이것을 수식으로 표현하면 H(x) = F(x) + x 라고 할 수 있습니다.
        * H(x)는 전체 conv layer들을 통과한 함수를 뜻합니다.
        * 원래는 전체 conv layer, 위 그림에서 H(x)를 학습해야했는데, 이렇게 skip connection을 이용함으로써 F(x)만 학습할 수 있게 됩니다. F(x)=H(x)−x 로 표현할 수 있으니, 이것은 즉 해당 block 에서 입력 x에 대한 잔차(residual) or 변화량(delta)만 학습한다고 할 수 있습니다.
        * 따라서 residual block 이라고 부르는 것입니다.
* 네트워크는 Residual만 학습하면 그만이며, 레이어가 Full mapping을 학습하기 보다 이런 조금의 변화(X에 대한 변화량(delda))만 학습하는 것입니다.
    * 만약 H(x)를 직접 학습시키는 대신에 F(x)인 Residual을 학습하는게 더 쉽다라는 가설이 참이라면, 어쩌면 대부분의 레이어가 잘 동작하려면 레이어의 출력이 Identity에 가까워야 할지 모른다는 것을 암시합니다.
    * 그러므로 Identity(Input)을 단순히 더해주고, 변화량(delta)만 학습시키면 됩니다.
* 정리하면 ResNet의 아이디어는 H(x) = F(x) + X 이니, F(x)를 학습시켜보면 어떨까? 하는 것이며, H(x)를 직접 배우는 대신에 X에 얼마의 값을 더하고 빼야할까?(Residual)를 배우는 것이 쉬울 것이라고 생각한 것이므로, 입력값을 어떻게 수정해야 하는지를 배운다고 보면 됩니다.

<br>

* 이 방식은 깊은 네트워크가 얕은 네트워크를 더 쉽게 emulate할 수 있게 해줍니다.
    * identity function에 대해 쉽게 학습이 되기를 기대하는 의미입니다.
    * 만약 슬라이드의 Residual Block안에 있는 2개 Conv layer의 weight를 0으로 설정한다면, 두 layer의 출력은 0이 되고 Residual Block의 최종 출력 결과는 identity를 계산하게 됩니다.
    * 또는 Input = output 이어야 하는 상황이라면 레이어의 출력인 F(x)가 0 이어야 하므로(residual = 0) 모든 가중치를 0으로 만들어주면 그만입니다.
* 또한, 깊은 네트워크에서 gradient의 흐름을 개선하는데에도 도움이 됩니다.
    * Back Propagation에서, Add gate는 입력 모두에 gradient를 전달해주는 gradient distributor 역할을 수행합니다.
    * 이러한 gradient의 전달이 Residual Block에서는 short cut으로 이루어지게 되므로, 깊은 네트워크에서 gradient의 흐름이 더 원활하게 이루어지게 됩니다.

<br>





# Full ResNet architecture

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186586617-89cf8b80-774f-43c2-b30e-646531d1a6cd.png">
</p>

* 전체 ResNet 구조에 대해 살펴보겠습니다.
* Residual Networks(ResNet)는 Residual Block을 쌓은 네트워크 구조입니다.
* 위 슬라이드를 보면, VGG에서 유사한 방식으로 residual block을 쌓은 형태라는 것을 알 수 있습니다.
    * Residual Block은 2개의 3 x 3 Conv 레이어로 구성되어있습니다.
    * 여러개의 stage로 나눠져있으며, stage가 시작할때 convolution시 stride=2를 적용하여 downsampling하고 그에따라 filter의 갯수를 2배로 늘립니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186587344-7b486f9f-d19e-40c6-8877-86a1e6bcd7b5.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186587503-1b14c16b-0440-45a0-9ed5-940568c61289.png">
</p>

* 또한 GoogLeNet과의 유사한 점은 다음의 2가지가 있습니다.
    * 처음의 몇개 layer에서 aggressive down sampling을 수행하여, 네트워크 초반에 연산량을 줄입니다.(Stem Network)
    * 마지막 Conv layer의 출력인 네트워크의 끝에는 FC-Layer가 없고, Global Average Pooling을 수행하여 파라미터를 줄입니다.
        * 이후 FC-Layer, softmax를 이용해 class수 만큼의 output을 출력합니다.
<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186588095-032470f5-c4c1-4696-bc25-311db9be6622.png">
</p>

* ResNet 모델의 Depth는 34, 50, 100까지 늘어나며, 논문에서는 ImageNet문제를 위해 152까지 늘렸습니다.
* ResNet-18의 구조는 다음과 같습니다.
    * Stem을 수행한 후, 총 4번의 stage를 반복하고 Linear layer(FC layer)로 결과를 출력합니다.
    * 각 stage에는 2번의 residual block과 4개의 Conv layer가 있습니다.
    * 18의 의미는 layer의 수를 의미합니다. (Stem에서 1개, 모든 stage에서 16개, 최종 출력에서 1개)
* ResNet-34의 구조는 다음과 같습니다.
    * Stem, 총 4번의 stage, FC layer의 형태는 동일합니다.
    * 각 stage에서 residual block(Conv layer)의 수가 더 증가했습니다.
    * 위 슬라이드 하단의 VGG-16과 비교해보면, ResNet이 더 적은 연산(FLOPS)을 수행하는 것을 알 수 있는데(4배 차이), 이는 Stem과 Global Average Pooling을 수행했기 때문입니다.

<br>





# Residual Networks: Bottleneck Block

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186614147-bb7c3912-813e-4400-b322-a7aa0fae4491.png">
</p>

* ResNet은 모델의 Depth가 50 이상일때 연산 효율을 높이기 위해 Bottleneck Layers를 도입합니다.
    * GoogLeNet에서 사용한 bottleneck layer와 유사한 개념입니다.
* Residual block의 conv layer에 들어가기 전에 1×1 conv layer를 이용해 차원(채널수)을 줄여서 3×3 conv layer의 연산량을 줄여주고, 이후에 1×1 conv layer를 이용해 다시 차원(채널수)을 늘리는 구조로 이루어져 있습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186615051-ddfb83bb-bbf2-4469-ab96-442c4e0c925d.png">
</p>

* 즉 Residual Network를 더 깊게 쌓기 위해 Bottleneck Block이라는 구조가 새롭게 만들어졌습니다.
* 슬라이드는 "Basic Residual block"과 "Bottleneck Residual block"을 비교한 것입니다.
    * Basic block
        * Basic Residual block은 2개의 3 x 3 Conv레이어를 쌓음으로써, 각각 9HWC^2이므로 총 18HWC^2의 부동소수점 연산이 필요합니다.
        * 즉 3x3 Conv를 두번 수행합니다.
    * Bottleneck block
        * 먼저, 1x1 Conv layer를 사용해 입력의 채널을 1/4로 줄입니다. 그러므로 FLOPs는 4HWC^2 입니다.
        * 3x3 Conv를 수행합니다. 그러므로 FLOPs는 9HWC^2 입니다.
        * 마지막으로, 다시 1x1 Conv layer를 통해 입력의 채널을 4배로 키웁니다. 그러므로 FLOPs는 4HWC^2 입니다.
        * 총 FLOPs는 17HWC^2 입니다.
* 위의 각 과정에서의 FLOPs를 모두 계산해보면, Bottleneck block이 더 깊어졌지만 연산량은 오히려 더 줄어들었다는 것을 알 수 있습니다다.
* 따라서, Basic에서 Bottleneck으로의 전환은 아래와 같은 효과를 얻게됩니다.
    * 더 적은 연산량
    * 더 높은 표현력(더 많은 layer을 통과하면서 더 많은 비선형성이 추가됨)

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186616754-338fbe51-f5f0-4b6f-818b-48b231472cc1.png">
</p>

* ResNet-34에서 Basic block을 Bottleneck block으로 전환한 네트워크 형태가 ResNet-50입니다.
    * Network는 더 깊어졌고, 레이어수가 3배가 되며, error는 더 줄어들었지만, 연산량에는 큰 변화가 없습니다.
* ResNet-50보다 더 많은 Bottleneck block을 쌓은 구조들이 ResNet-101, ResNet-152이며 깊어질수록 네트워크가 더 잘 동작하므로 error는 조금씩 감소하였습니다.
    * 정확도가 더 높지만 연산 부담이 큰 모델입니다.

<br>

<p align="center">
<img alt="image" src="">
</p>

* ResNet을 훈련할때 여러가지 구체적인 방법들을 사용했습니다.
    * 모든 conv layer 이후에 batch normalization 을 사용했습니다.
    * He initialization 방법으로 가중치 초기화를 했습니다.
    * optimizer로 SGD+Momentum을 사용하고 초기 learning rate 는 0.1 로 설정하여 validation error 가 줄어들지 않는 시점에 learning를 10배씩 감소시키는 learning rate decay를 사용했습니다.
    * mini-batch size는 256입니다.
    * weight-decay는 1e-5를 사용하고 dropout은 사용하지 않았습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186618200-a878eada-6817-4ffa-b85b-05882c90ba70.png">
</p>

* ResNet은 네트워크가 깊어질수록 error가 점점 줄어드는 경향을 보이며 엄청난 격차를 보이는 좋은 성능으로 대회에서 우승합니다.
    * degradation문제 없이 Very deep network를 아주 잘 학습시킬 수 있었습니다.
* ResNet은 ILSVRC와 COCO의 모든 대회종목을 2등과의 엄청난 격차로 휩쓸었습니다.
* Total top-5 Error는 3.6%로, ImageNet paper에서 제시한 "인간의 성능" 보다 뛰어났습니다.

<br>





# Comparing complexity

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186620818-d492056d-beb9-46d2-81ca-6b10f8dcecac.png">
</p>

* 왼쪽 그래프는 성능을 비교하는 그래프이고, 오른쪽 그래프는 연산 수를 비교하는 그래프입니다.
    * 오른쪽 그래프에서 x축은 모델의 연산량을 의미하고 y축은 모델의 성능(accuracy)을 의미합니다.
    * 오른쪽 그래프에서 오른쪽으로 갈 수록 헤비한 네트워크, 위로 갈수록 성능이 좋은 네트워크, 원 크기는 파라미터 개수(클수록 메모리가 부담)
* 모델 별로 성능과 복잡도(complexity)를 비교해서 살펴보겠습니다.
    * Inception-v4는 ResNet+inception모델이 합쳐진 개념으로 가장 좋은 성능을 보입니다.
    * AlexNet은 Accuracy가 낮으며 연산수는 적지만, 파라미터 개수가 많아 네트워크 입니다.
    * VGG를 보면 연산량과 메모리 사용량이 엄청 커서 효율성이 작습니다.
    * GoogLeNet은 연산량과 메모리사용량이 굉장히 작은 효율적인 모델입니다.
    * ResNet은 심플한 디자인, 양호한 효율성의 네트워크로 정확도가 아주 높아 성능이 좋습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186622933-495f2014-dda6-4ce0-b70e-74ae7d2a7514.png">
</p>

* 다음으로, 각 모델에서 forward pass 하는데에 필요한 시간과 전력사용량을 비교한 그래프 입니다.
* 왼쪽 그래프가 forward pass 하는데 걸리는 시간, 오른쪽 그래프가 전력사용량 입니다.
* VGG가 시간이 오래 걸리는 것을 확인할 수 있고, ResNet은 적당한 정도로 분포하는 것을 알 수 있습니다.

<br>
<br>





# Model Ensembles(2016)

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186623958-1509cbb0-5643-49c2-802e-f163d92bab74.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186624029-b19f7491-aa73-4399-82e3-33ccd734e222.png">
</p>

* 2016년에는 이전처럼 혁신적인 시도보다는 이전까지의 모델을 이용한 앙상블 방식의 모델이 많이 쓰였습니다.
* Inception, Inception-Resnet, Resnet, Wide Resnet models의 Multi-scale ensemble을 사용하여 0.6%를 개선시켜 우승하였습니다.

<br>
<br>





# SENet(2017)

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186627541-9a395f5e-3136-4d57-b240-cc6f6fb5a820.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186627591-8b6e2e09-701d-4271-80e5-c6aa85996d3a.png">
</p>

* 2017년 ResNext의 아이디어를 바탕으로한 여러 연구들을 통해서 Squeeze-and-Excitation(SE)라는 방법을 사용한 SENet이라는 모델이 나왔습니다.
* 그리고 이 모델이 2017년 좋은 성능을 보인 것을 마지막으로 ImageNet challenge는 끝납니다.

<br>
<br>





# Other Networks

* 위에 모델들에 이어서 추가적으로 몇가지 중요한 모델 구조, ResNet에서 변형된 모델 구조들에 대해 살펴보겠습니다.

<br>





# Network in Network(NiN)

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186643253-3b0c8bf0-c0c7-4b9c-aeac-bd9e523056b6.png">
</p>

* 2014년에 나온 논문으로 Network in Network 입니다.
* Network in Network의 기본 아이디어는 MLP Conv layer로, 각 Conv layer안에 FC-layer (multi-layer perceptron)를 넣는 것입니다.
    * convolution시 filter 대신에 MLP를 사용해서 feature를 추출하는 방법을 고안했습니다.
    * 즉, Conv layer에서 filter를 거쳐나온 output을 여러개의 FC-layer에 통과시킴으로써 추상적인(abstract) feature 들을 추출해 더 복잡한(complex) activation map을 출력할 수 있도록 합니다.
* 이때, NiN 에서 말하는 FC-layer는 1×1 Conv layer라고 할 수도 있습니다.
* GoogLeNet과 ResNet에서 사용하는 bottleneck의 개념이 바로 이 NiN 에서 가져온 아이디어이기 때문에 NiN 은 큰 의미를 가집니다.

<br>
<br>




# Identity Mappings in Deep Residual Networks

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186646479-ca1022e3-b713-4fde-bf89-bcecda9c9ca5.png">
</p>

* 2014년에 나온 논문으로 Identity Mappings in Deep Residual Networks 입니다.
* 여기서는 ResNet block의 skip connection부분이 아닌 direct path 부분을 조절하여 모델의 성능을 올렸습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186646198-c7329249-b8e4-46d3-86c0-1bfdb30bb7c7.png">
</p>

* "Pre-Activation"은 operation 순서를 바꿔 본 시도로, ReLU를 conv레이어보다 먼저 넣었습니다.
* Original ResNet block 에서는 윗단 레이어은 ReLU를 거친 positive값만 받기때문에, Identity function을 제대로 학습하지 못할 것 같다는 생각에서 출발한 시도입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186646227-e7de6310-2281-4485-9b1e-8e7176a82d6d.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186647463-4bd5225e-926a-4237-857c-228ac35954c8.png">
</p>

* 여러 실험들을 통해 논문에서 얻어낸 결론을 요약해보면 다음과 같습니다.
    * shortcut path (skip connection 부분)의 정보는 최대한 손상시키지 않는 것이 backpropagation, 정보 전달 측면에서 유리합니다.
    * residual path에서는 shortcut과 합쳐주기 전에 activation function을 적용하는 것이 유리하다는 것을 알아냈습니다.
* Accuracy는 1퍼센트정도 늘어나며, 크게 차이가 없으므로, 잘 사용되지는 않습니다. 

<br>
<br>





# Wide Residual Networks

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186648554-d0a61a58-0968-41e9-85cc-90179084523e.png">
</p>

* 또 다른 ResNet 에서 개선된 모델로 Wide ResNet이 있습니다.
* 본 논문의 저자는 ResNet에서 네트워크의 깊이(depth)가 중요한게 아니라 residual 구조가 성능 향상에 큰 도움을 줬다고 주장합니다.
* 따라서 네트워크가 extreamly 하게 깊어질 필요가 없다고 생각하여 residual block을 더 넓게 만들었습니다.
    * 본 논문에서 wide 하다는 의미는 channel의 개수가 많다는 것을 의미합니다.
    * 즉, WRN은 residual block을 구성하는 convolution layer의 filter 수를 증가시켜서 신경망의 넓이를 증가시켰습니다.
    * Widening factor k에 따라 channel 개수가 늘어나는 구조입니다.
    * 기존의 ResNet에는 Block 당 F개의 filter만 있었다면, F * K 개의 필터로 구성했습니다.
* 이렇게 각 레이어를 넓게(filter 의 갯수를 늘려) 구성하여 단 50개의 레이어만으로도 기존 152개의 레이어를 가지는 ResNet 보다 성능이 좋게 나오는 것을 증명했습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186650826-68fa2748-7d4b-434f-b7ff-08fbaee9717a.png">
</p>

* 저자들은 기존 구조의 순서인 Conv-BN-ReLU가 아닌 BN-ReLU-Conv로 순서를 변경했습니다. 후자가 더 빨리 훈련하고 좋은 결과를 냈다. residual block의 power를 향상시킬수 있는 간단한 3가지 필수적인 방법은 다음과 같습니다.
    1. 합성곱층을 block마다 더 추가한다.
    2. feature planes를 더 추가하면서 합성곱층의 너비를 넓힌다.
    3. 합성곱층의 필터 size를 증가시킨다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186651083-a98b6472-2cc7-463f-b8df-6166d2121ec2.png">
</p>

* 논문 저자들의 residual network의 일반적인 구조입니다.
* 논문에서 깊이 factor는 l, 너비 factor는 k로 나타냈습니다. figure1(a),(c)는 basic 모델과 basic-wide모델의 예를 보여줍니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186653007-17a4c0c5-840a-4b60-b277-f5e30cfe5c0c.png">
</p>

* 위 표는 ImageNet과 COCO dataset의 성능을 비교합니다.
* Width가 증가할수록 성능이 올라가는 모습을 볼 수 있습니다.
* 정리하면 다음과 같습니다.
    1. widening은 여러 깊이의 residual network에서 성능을 일관되게 향상시킵니다.
    2. 깊이와 너비 둘다 증가시키는것은 파라미터의 수가 너무 많아지거나 강한 regularization이 필요해지기 전까지는 도움이 됩니다.
    3. 얇은 신경망과 동일한 수의 매개변수를 가진 넓은 신경망이 동일하거나 더 나은 성능을 낼 수 있기 때문에 residual network의 매우 깊은 깊이는 정규화 효과가 없는 것으로 보입니다. 더군다나, wide network는 얇은 네트워크보다 2배 이상의 많은 수의 매개변수를 사용하여 성공적으로 학습할 수 있습니다.

<br>
<br>





# ResNeXt

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186653462-48df7544-0423-4eeb-b894-74155c9984d6.png">
</p>

* ResNet 논문의 저자들이 제안한 ResNet 을 발전시킨 형태인 ResNext 모델이 있습니다.
* 여기에서도 residual block 의 width를 늘리는 전략, 즉 conv layer의 filter의 갯수를 늘리는 방법을 제안합니다.
* 독특한 점이 residual block 에서 여러 개의 병렬 pathway를 사용하는 구조입니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186653957-6bf239a3-6501-46cf-83aa-c195051f5440.png">
</p>

* ResNext는 ResNet의 “Bottleneck” block을 병렬로 연결한 구조이며, 위 슬라이드의 오른쪽 구조와 같이 G개의 parallel pathway(block)으로 구성됩니다.
* 각 pathway에서 3x3 Conv layer의 연산을 위해 줄였다가 다시 증가시키는 채널의 수를 소문자 c라고 하면, 이러한 G개의 병렬 구조가 Bottleneck block과 같은 연산량을 갖게 하는 c의 값을 quadratic equation을 세우고 풀 수 있습니다.
    * 위 슬라이드의 아랫부분의 식이 quadratic equation이며, 아래의 Example은 다음과 같은 의미를 갖습니다.
        * Ex1) C=64, G=4라고 했을 때, c=24가 되어야 Bottleneck block과 같은 FLOPs를 갖습니다.
        * Ex2) C=64, G=32라고 했을 때, c=4가 되어야 Bottleneck block과 같은 FLOPs를 갖습니다.
    * 각 pathway에서 3x3 Conv layer의 연산을 위해 줄였다가 다시 증가시키는 채널의 수를 소문자 c라고 하고,
    * 각각의 pathway에서 FLOPs를 계산한 후, 모두 더하면 전체 FLOPs를 구할 수 있습니다.
* 이러한 방법은 네트워크 디자인을 수정하는 새로운 메커니즘을 제공합니다.
    * 연산량을 유지하는 채널의 수를 설정하는 것 대신에, 방정식을 풀어 pathway의 수 G를 설정할 수도 있습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186655527-b60bb7c8-9afd-447b-add4-f1acc8441b35.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186655564-897fa76b-5747-41f0-92f7-3667e1aced63.png">
</p>

* ResNext에서는 단순히 병렬적으로 사용하는 것이 아니라 1 x 1 Conv에서 채널의 1/4로 축소하는 것이 아니라 'c' 만큼 축소했는데 9Gc^2 + 8GCc - 17C^2 = 0이라는 Flops 수를 구하는 방정식으로 통해서 임의로 정한 C와 G를 이용했을 때, 기존의 bottleneck residual block과 동일한 연산이 수행되는 c를 구해 그 값으로 c를 정한다고 합니다.
* Grouped Convolution은 Group의 수만큼 GPU를 병렬적으로 사용하는데, 이때 채널을 GPU의 수만큼 분리해서 각 GPU별로 학습을 진행합니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186655929-71af17a4-9bda-483c-99c2-7e42b7a4b4c0.png">
</p>

* 위 사항들을 고려했을때 다음과 같이 표기할 수 있습니다.

<br>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186656089-8ea4093d-5d48-4f1c-9557-effe7ecf308f.png">
</p>

* ResNext의 parallel pathway 구조를 이용하면, 연산량은 유지하면서 성능은 향상시킬 수 있습니다.
* 위 슬라이드는 (연산량은 유지하면서) Group의 수를 늘릴수록 성능이 좋아진다는 것을 보여줍니다.

<br>
<br>





# Deep Networks with Stochastic Depth

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186656228-e88b3461-adec-4bba-891f-25946160fefa.png">
</p>

* ResNet의 성능을 개선하고자 하는 방법은 계속되는데, Stochastic Depth 이라는 논문이 있습니다.
* 네트워크가 깊어지면 backpropagation 과정에서 gradient가 전달될 수록 점점 gradient가 작아지는 gradient vanishing 문제가 발생하곤했습니다.
* 이러한 문제를 해결하기 위해 train time 에 레이어의 일부를 dropout 하는 방법입니다.
    * 임의로 dropout 된 짧은 구조의 네트워크로 수월하게 학습을 하고 test time 에는 전체 네트워크를 이용해서 output 을 내는 방법입니다.

<br>
<br>





# FractalNet: Ultra-Deep Neural Networks without Residuals

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186656969-94ea903c-2a79-49eb-a35b-dc59418ff52d.png">
</p>

* FractalNet 에서는 residual connection을 사용하지 않고 초기의 레이어(shallow)의 정보과 깊은 레이어(deep)의 정보를 모두 잘 전달하는 것이 중요하다는 관점에서 fractal 한 구조를 사용했습니다.
* 따라서 shallow layer 의 정보와 deep layer 의 정보를 모두 출력에 전달합니다.
* 또한 dropout 처럼 train time 에는 임의의 일부 경로의 정보를 사용해서 학습하고 test time 에 전체 경로를 이용하는 방법을 사용합니다.

<br>
<br>





# DenseNet

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186657256-9c0f6925-f284-4cab-917e-365b2ea3d940.png">
</p>

* DenseNet은 ResNet에서의 shortcut connection(skip connection)을 다른 방법으로 수행한 네트워크입니다.
    * ResNet에서는 Additive shortcut을 수행하였는데, DenseNet에서는 Concatenation shortcut을 사용합니다.
    * 즉, 이전 layer의 feature를 Add하는 것 대신에 Concatenate하는 것입니다.
* 즉, 초기 input 이 모든 layer 에 동일하게 들어가고, 모든 레이어에서의 ouput 이 합쳐져(concat) 그 다음 conv layer의 input으로 들어가는 구조로 되어 있습니다.
* 논문의 저자들을 이러한 Dense block 이 gradient vanishing 문제를 완화할 수 있고 feature 들을 더 잘 전달하고 사용할 수 있게끔 한다고 주장합니다.

<br>
<br>





# SqueezeNet

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186657493-79062775-9c05-41be-867a-96f35ff50a91.png">
</p>

* SqueezeNet은 효율성(efficient)를 중점적으로 하여 설계된 모델입니다.
* SqueezeNet에서 연산 효율을 올리기 위해 fire module 이라는 것을 사용했습니다.
* Fire module은 1×1 conv layer로 구성되어 있는 squeeze layer와 1×1 conv layer, 3×3 conv layer로 구성되어 있는 expand layer로 구성되어 있습니다.
* 이러한 fire module을 사용한 squeezeNet은 AlexNet 보다 50배 적은 파라미터를 가짐과 동시에 비슷한 성능을 보였습니다.
* squeezeNet을 더 압축하면 AlexNet 보다 500배 더 작아지게 된다고 합니다.

<br>
<br>





# Main takeaways $ Summary

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186659919-fd0b533d-b6a4-4251-91ef-8dc2ab5f515c.png">
</p>

<p align="center">
<img alt="image" src="https://user-images.githubusercontent.com/77891754/186659944-3e15e77a-bf1f-406d-b03d-7364bb09c0fe.png">
</p>

* 위 슬라이드는 이번 강의에서 배운 내용들을 요약한 것입니다.





